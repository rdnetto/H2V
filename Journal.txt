================================================================================
Wednesday 30 April 2014
Encountered a temporary set-back related to a GHC bug where undefined
typeclass members could result in stack overflows. Found a workaround, but
spent most of the break doing doing so.

DFD generation code is slowly underway - implementing support for expressions one at a
time as required by test case (Fibonacci sequence).

The minimal implementation may be larger than expected due to
interdependencies. e.g. pattern matching requires if statements, which require
the ability to import functions from Prelude. However, this does not change
the overall implementation time because these features would need to be
implemented sooner or later anyway.


Git commits:
83108f4  2014-04-30 00:56:52 +1000  WIP: adding support for IF statements
93b515e  2014-04-30 00:58:22 +1000  TEMP: Changed test.hs so that functions are in strict dependency order. Revert once we have better dependency resolution
4c6c526  2014-04-29 02:42:53 +1000  Added support for let statements, function application.
336a832  2014-04-29 02:41:54 +1000  Preliminary: added some basic definitions of built-in operators
2497610  2014-04-29 02:40:53 +1000  Added utility methods for converting qualified names to strings, removed stale code.
770ce6f  2014-04-29 02:38:45 +1000  BUG FIX: State modification code was commented out
4139525  2014-04-29 02:37:58 +1000  BUG FIX: Was generating a redundant 'if true then X else _'
36ca55b  2014-04-29 02:37:18 +1000  Replaced DNode.DArgument with DVariable, which may or may not have a subexpression.
6b92c3a  2014-04-29 02:35:14 +1000  Started implementing monadic DFD generation logic.
6c7c79d  2014-04-29 02:46:02 +1000  TEMP: Disable outdated Graphviz code until the new DFD code is stable
2535b14  2014-04-28 10:59:33 +1000  BUG FIX: build failed when both mtl and monads-tf were installed, since they both contain Control.Monad.State
18ffe93  2014-04-27 01:22:06 +1000  BUG FIX: replaced explicit definition for show with inherited one (that does not trigger bug).
7f2e8de  2014-04-25 20:19:26 +1000  BUG FIX: The default implementation of show seems to cause stack overflows. Manually implementing it is a (inelegant) workaround. See: http://www.reddit.com/r/haskellquestions/comments/23xueu/ghc_bug_or_newbie_mistake/
4e4d0d4  2014-04-24 22:45:11 +1000  Rewrote pattern matching logic to correctly handle the case where none of the patterns impose constraints e.g. they are all variables
f07e733  2014-04-24 22:43:10 +1000  Added notes on debugging.

================================================================================
Tuesday 15 April 2014
Fixed bug affecting state monad. This bug can be solved more easily in the future by using scoped type annotations.
Function-level pattern matching has been implemented - need to refactor so that it can be used for arbitrary variables.
Code is now in good shape for the DFD node generation logic to be implemented. Once this is complete, the legacy Graphviz code will need to be updated to use the new interface.

Git commits:
210ca19  2014-04-15 22:56:45 +1000  Cleaned up code, removed legacy cruft
ff08611  2014-04-15 22:35:02 +1000  Implemented pattern matching logic.
007c353  2014-04-14 12:21:42 +1000  Fixed type inference bug. Was caused by not wrapping result in return.

================================================================================
Wednesday 09 April 2014
Started refactoring Graphviz code to separate graph traversal from code generation.
Key structures have been defined, algorithms just need to be ported across from existing code.
Currently having issues with state monad - need to prototype on smaller scale to identify the problem (something to do type inference).

Git commits:
d5f9124  2014-04-09 02:46:16 +1000  Added spike file to test monad code.
e0cee23  2014-04-09 02:04:11 +1000  WIP: NodeGen monad definition.
1ef7d7e  2014-04-06 22:34:41 +1000  Defined the DFD structure.
2d65e54  2014-04-06 20:04:49 +1000  Moved Graphviz generation code and type definitions into separate files.
aad45d1  2014-04-02 00:50:59 +1100  WIP
2e6bcb1  2014-03-25 23:00:42 +1100  Added script for submitting progress reports

================================================================================
Tuesday 25 March 2014
Implemented a rough prototype of Graphviz generation. It can generate the graph of f, but not fib, which requires pattern matching.
See H2V/test.hs for the source code, and H2V/test.png for the output. (The make debug target is responsible for rendering test.gv into test.png.)

Graph generation consists of a two step process:
-the AST is 'cleaned', to reduce the number of syntactic structures used. Any additional logic required is generated at this point.
-the cleaned AST (now referred to as a DFD) is transformed into Graphviz code via graph traversal
    +each function and variable has a node with a unique ID (implemented using a monotonically counting monad)
    +the traversal functions (which are defined recursively) keep track of the local namespace (a mapping between variable names and node IDs)
    +blue edges are used to identify functions that will undergo application (denoted by <-). Everything is curried right now, which isn't particularly readable - need to look at optimizing this in the future. (This may require the AST structure to be extended - the alternative is an external map which provides additional information. That said, we will need to store additional info later anyway in order to identify thunk boundaries)

-The pattern matching and function generation logic need to be rewritten; the current approach is a hack that is not sufficiently generalizable
-Graphviz generation is quite similar to Verilog generation. The main difference is that Verilog requires an explicit definition of the interfaces between nodes. It should be easy to implement Verilog generation once Graphviz generation is feature-complete.
-It looks like currying (partial application) will be possible; this arises quite naturally from mapping the function application operator (->) to a module which has an input (representing the argument), an input-output pair (representing a function of one argument), and another input-output pair (representing a partially applied function.) The inputs will vary in widths, depending on the degree of application. As this would result in many extraneous modules, combining as much application into a single module as possible is recommended.
    +This implies the rather useful insight that the generated visual graph is an exact representation of what the inter-module connections will be for a given program.

The Requirements Analysis has been submitted to Moodle.

Notes:
Documentation on parsing API:
    http://hackage.haskell.org/package/haskell-src-1.0.1.5/docs/Language-Haskell-Syntax.html

After populating the signals for a Qsys Component, you can go back to Files to
generate a file with the given signals.

Only reads can be pipelined, not writes. However, burst mode can be used for
both reads and writes. (Burst = accessing an entire row of data at once.)

Useful info on DE0-Nano SDRAM, and potential clock skew issues:
        ftp://ftp.altera.com/up/pub/Altera_Material/12.0/Tutorials/Verilog/DE0-Nano/Using_the_SDRAM.pdf

Git commits:
4ad668b  2014-03-25 22:08:45 +1100  Graph generation now works with subdeclarations. Pattern matching is broken (requires additional cleaning logic).
f8d67d2  2014-03-25 22:23:06 +1100  Graph generation now works, except for subdeclarations
a704d24  2014-03-24 19:56:22 +1100  Graphviz generation now working, except for argument resolution
c552d4c  2014-03-25 22:23:28 +1100  Improved Makefile to automate testing of Graphviz generation
f1dfc2a  2014-03-25 22:17:51 +1100  Node ID Counter monad now works.
d605911  2014-03-22 18:32:46 +1100  Moved build files into separate directory
7bf76db  2014-03-22 18:32:36 +1100  Refactored code into separate files
666cb8c  2014-03-22 17:47:09 +1100  Requirements Analysis: corrected typo.

================================================================================
Wednesday 19 March 2014
Read up on functors and monads. They seem to consist primarily of glue code
that does pattern matching and destructuring. However, if all stateful
operations (e.g. memory accesses) are encapsulated in them, then figuring out
how to schedule them via lazy evaluation may be non-trivial. A fake pure
function might be easier (for reads, anyway). They also imply a need for
first-class functions.

Familiarised myself with Qsys, and its interface for creating components.
Integrating the compiler with it should be easy.
In addition to the memory protocol, there is also a streaming protocol that
may be easy to support - need to see if it has any useful applications.

Notes:
Nios II Tutorial (useful as a checklist):
    http://www.altera.com/literature/tt/tt_nios2_hardware_tutorial.pdf

Summary of Qsys components:
    ftp://ftp.altera.com/up/pub/Altera_Material/12.0/Tutorials/making_qsys_components.pdf

Qsys Bus Protocol Specifications:
    http://www.altera.com/literature/manual/mnl_avalon_spec.pdf

Creating QSys Peripherals:
-create new component
-add interfaces, and enough signals to get rid of warnings
    +Clock Input
    +Reset Input
    +Avalon Memory Mapped Master (need waitrequest for multi-master)
    +Custom Instruction Slave
-add component to qsys file and hook it up to the buses
-signals are exported as conduits, unless verilog modules have been added to
handle them

This makes integrating into QSys really easy, and just requires us to
implement bus client logic.

The file generated by New Component is *_hw.tcl, and has a very simple format
that could easily be generated from a template.

Info on accelerator design:
    https://www.lri.fr/~de/ug_nios2_custom_instruction.pdf
    -can explicitly tell Quartus how many cycles we will take for fixed length
    functions

Git commits:
3d7b6a8  2014-03-19 00:03:52 +1100  Added scratch directory to gitignore. Useful for keeping spikes in.
d3ac736  2014-03-19 00:00:18 +1100  Completed Requirements Analysis
d57fd3e  2014-03-18 23:59:39 +1100  Added pin assignment file.
000e8b9  2014-03-16 22:52:25 +1100  Added notes on Haskell. Functor and Monad sections are now complete.

================================================================================
Tuesday 11 March 2014
Investigated use of GHC's parser. Decided against using it as there is a
standard library (haskell-src) better suited to this task.
Wrote a simple parsing spike to familiarise myself with haskell-src.

Added Risk Analysis and an early draft of the Requirements Analysis.
Basic structure and key requirements have been defined, some sections will require further research.

Notes:
The haskell standard libraries contains haskell-src, a library specifically
for parsing Haskell. This will be /much/ easier to use than GHC, since it will
not require reverse engineering. haskell-src-ext may also be useful.
    http://hackage.haskell.org/package/haskell-src
    http://hackage.haskell.org/package/haskell-src-1.0.1.5/docs/Language-Haskell-Parser.html

There's a Haskell to Javascript compiler here that could be interesting to
look at (in terms of how it handles parsing and AST manipulation).
    https://github.com/faylang/fay

Test input for parsing spike:
f x a b c = a2 * x + b * x + c where
    a2 = a * a

Test output for parsing spike:
Module: Main
        Function: f
                        Match:
                                Pattern: [HsPVar (HsIdent "x"),HsPVar (HsIdent "a"),HsPVar (HsIdent "b"),HsPVar (HsIdent "c")]
                                RHS: HsUnGuardedRhs (HsInfixApp (HsInfixApp (HsInfixApp (HsInfixApp (HsVar (UnQual (HsIdent "a2"))) (HsQVarOp (UnQual (HsSymbol "*"))) (HsVar (UnQual (HsIdent "x")))) (HsQVarOp (UnQual (HsSymbol "+"))) (HsVar (UnQual (HsIdent "b")))) (HsQVarOp (UnQual (HsSymbol "*"))) (HsVar (UnQual (HsIdent "x")))) (HsQVarOp (UnQual (HsSymbol "+"))) (HsVar (UnQual (HsIdent "c"))))
                                Declarations:
                                        Pattern Binding:
                                                Pattern: HsPVar (HsIdent "a2")
                                                RHS: HsUnGuardedRhs (HsInfixApp (HsVar (UnQual (HsIdent "a"))) (HsQVarOp (UnQual (HsSymbol "*"))) (HsVar (UnQual (HsIdent "a"))))
                                                Declarations:

Git commits:
9d40f9e  2014-03-11 19:53:56 +1100  Early draft of Requirements Analysis. Some sections are pending further research.
2a89fd7  2014-03-09 21:44:29 +1100  Parsing spike. Useful for examining code and familiarizing myself with the parser's types
11517af  2014-03-09 21:43:32 +1100  Added a file to hold use cases. Currently only contains Fibonnacci sequence.
a982a70  2014-03-05 19:52:49 +1100  Completed Risk Analysis
15ebc1a  2014-03-05 19:33:29 +1100  Moved files from project proposal into dedicated subdirectory

================================================================================
Wednesday 05 March 2014
Prototype and design proposal completed.

Git commits:
78d8a17  2014-03-04 23:17:51 +1100  Committed changes to report
4ea2686  2014-02-25 22:10:31 +1100  Completed prototype
540266d  2014-02-24 20:19:34 +1100  Added operator precedence
bc8b5f7  2014-02-24 19:08:08 +1100  Implemented printing of AST.
1e39577  2014-02-24 19:07:29 +1100  Replaced 2-tuple with a Function structure.
8c9c534  2014-02-24 18:16:49 +1100  Rewrote in Rust.
4adace7  2014-02-24 02:54:57 +1100  Implemented a large amount of parsing logic. At this point I'm giving up on a C++ implementation.
31f7a64  2014-02-19 21:09:19 +1100  Initial commit for H2V project
7feb560  2014-02-19 20:27:08 +1100  Updated design summary
9ed76ba  2014-02-16 22:07:30 +1100  Added discussion of Bison & Yacc
c3c8b00  2014-02-02 19:32:07 +1100  Initial commit - did first draft of preliminary design.

