================================================================================
Wednesday 19 March 2014
Read up on functors and monads. They seem to consist primarily of glue code
that does pattern matching and destructuring. However, if all stateful
operations (e.g. memory accesses) are encapsulated in them, then figuring out
how to schedule them via lazy evaluation may be non-trivial. A fake pure
function might be easier (for reads, anyway). They also imply a need for
first-class functions.

Familiarised myself with Qsys, and its interface for creating components.
Integrating the compiler with it should be easy.
In addition to the memory protocol, there is also a streaming protocol that
may be easy to support - need to see if it has any useful applications.

Notes:
Nios II Tutorial (useful as a checklist):
    http://www.altera.com/literature/tt/tt_nios2_hardware_tutorial.pdf

Sumamry of Qsys components:
    ftp://ftp.altera.com/up/pub/Altera_Material/12.0/Tutorials/making_qsys_components.pdf

Qsys Bus Protocol Specifications:
    http://www.altera.com/literature/manual/mnl_avalon_spec.pdf

Creating QSys Peripherals:
-create new component
-add interfaces, and enough signals to get rid of warnings
    +Clock Input
    +Reset Input
    +Avalon Memory Mapped Master (need waitrequest for multi-master)
    +Custom Instruction Slave
-add component to qsys file and hook it up to the buses
-signals are exported as conduits, unless verilog modules have been added to
handle them

This makes integrating into QSys really easy, and just requires us to
implement bus client logic.

The file generated by New Component is *_hw.tcl, and has a very simple format
that could easily be generated from a template.

Info on accelerator design:
    https://www.lri.fr/~de/ug_nios2_custom_instruction.pdf
    -can explicitly tell Quartus how many cycles we will take for fixed length
    functions

Git commits:
3d7b6a8  2014-03-19 00:03:52 +1100  Added scratch directory to gitignore. Useful for keeping spikes in.
d3ac736  2014-03-19 00:00:18 +1100  Completed Requirements Analysis
d57fd3e  2014-03-18 23:59:39 +1100  Added pin assignment file.
000e8b9  2014-03-16 22:52:25 +1100  Added notes on Haskell. Functor and Monad sections are now complete.

================================================================================
Tuesday 11 March 2014
Investigated use of GHC's parser. Decided against using it as there is a
standard library (haskell-src) better suited to this task.
Wrote a simple parsing spike to familiarise myself with haskell-src.

Added Risk Analysis and an early draft of the Requirements Analysis.
Basic structure and key requirements have been defined, some sections will require further research.

Notes:
The haskell standard libraries contains haskell-src, a library specifically
for parsing Haskell. This will be /much/ easier to use than GHC, since it will
not require reverse engineering. haskell-src-ext may also be useful.
    http://hackage.haskell.org/package/haskell-src
    http://hackage.haskell.org/package/haskell-src-1.0.1.5/docs/Language-Haskell-Parser.html

There's a Haskell to Javascript compiler here that could be interesting to
look at (in terms of how it handles parsing and AST manipulation).
    https://github.com/faylang/fay

Test input for parsing spike:
f x a b c = a2 * x + b * x + c where
    a2 = a * a

Test output for parsing spike:
Module: Main
        Function: f
                        Match:
                                Pattern: [HsPVar (HsIdent "x"),HsPVar (HsIdent "a"),HsPVar (HsIdent "b"),HsPVar (HsIdent "c")]
                                RHS: HsUnGuardedRhs (HsInfixApp (HsInfixApp (HsInfixApp (HsInfixApp (HsVar (UnQual (HsIdent "a2"))) (HsQVarOp (UnQual (HsSymbol "*"))) (HsVar (UnQual (HsIdent "x")))) (HsQVarOp (UnQual (HsSymbol "+"))) (HsVar (UnQual (HsIdent "b")))) (HsQVarOp (UnQual (HsSymbol "*"))) (HsVar (UnQual (HsIdent "x")))) (HsQVarOp (UnQual (HsSymbol "+"))) (HsVar (UnQual (HsIdent "c"))))
                                Declarations:
                                        Pattern Binding:
                                                Pattern: HsPVar (HsIdent "a2")
                                                RHS: HsUnGuardedRhs (HsInfixApp (HsVar (UnQual (HsIdent "a"))) (HsQVarOp (UnQual (HsSymbol "*"))) (HsVar (UnQual (HsIdent "a"))))
                                                Declarations:

Git commits:
9d40f9e  2014-03-11 19:53:56 +1100  Early draft of Requirements Analysis. Some sections are pending further research.
2a89fd7  2014-03-09 21:44:29 +1100  Parsing spike. Useful for examining code and familiarizing myself with the parser's types
11517af  2014-03-09 21:43:32 +1100  Added a file to hold use cases. Currently only contains Fibonnacci sequence.
a982a70  2014-03-05 19:52:49 +1100  Completed Risk Analysis
15ebc1a  2014-03-05 19:33:29 +1100  Moved files from project proposal into dedicated subdirectory

================================================================================
Wednesday 05 March 2014
Prototype and design proposal completed.

Git commits:
78d8a17  2014-03-04 23:17:51 +1100  Committed changes to report
4ea2686  2014-02-25 22:10:31 +1100  Completed prototype
540266d  2014-02-24 20:19:34 +1100  Added operator precedence
bc8b5f7  2014-02-24 19:08:08 +1100  Implemented printing of AST.
1e39577  2014-02-24 19:07:29 +1100  Replaced 2-tuple with a Function structure.
8c9c534  2014-02-24 18:16:49 +1100  Rewrote in Rust.
4adace7  2014-02-24 02:54:57 +1100  Implemented a large amount of parsing logic. At this point I'm giving up on a C++ implementation.
31f7a64  2014-02-19 21:09:19 +1100  Initial commit for H2V project
7feb560  2014-02-19 20:27:08 +1100  Updated design summary
9ed76ba  2014-02-16 22:07:30 +1100  Added discussion of Bison & Yacc
c3c8b00  2014-02-02 19:32:07 +1100  Initial commit - did first draft of preliminary design.

