================================================================================
Thursday 09 October 2014
Finished implementing decons and concat for non-parallel case. Will only implement parallel versions if needed for examples.
Implemented parallel list protocol, including map and fold (reduce). Performed optimizations to reduce latency.
Defined an operator (|||) to annotate functions/lists with their parallelism.
Attempted to implement compilation of recursive methods involving lists, but abandoned this idea as it would take too long.
Test cases are defined in H2V/tests/lists2.hs, output (via SignalTap) is in 'Parallel {Map,Fold} (signaltap).png'

Created early draft of poster - mostly defines layout. See ./docs/Poster/Poster.pptx

Git commits:
d4b9a40  2014-10-09 11:34:11 +1100  BUG FIX: macro filter crashed if recursive functions were present
a8169d0  2014-10-09 11:25:20 +1100  BUG FIX: fixed decons/tuple regressions caused by parallel list patches
1a16882  2014-10-09 11:23:05 +1100  BUG FIX: getPar didn't consider arguments
9118487  2014-10-08 21:28:15 +1100  Added early draft of poster.
08924d4  2014-10-08 18:56:44 +1100  Test case for mfoldr
179a08e  2014-10-08 18:06:43 +1100  FoldMacro: Changed list access logic to Mealy design to reduce latency
657a6e1  2014-10-08 17:47:31 +1100  BUG FIX: FoldMacro - indices were off by 1
e4c42ab  2014-10-08 17:47:11 +1100  BUG FIX: BoundedEnum kept value_valid high after reaching end of list
0f99a57  2014-10-08 17:27:25 +1100  BUG FIX: operators passed to macros were not have modules generated for them
8d19ff3  2014-10-08 09:48:40 +1100  Implemented fold using shifting design (O(N) function instances for N-parallelism)
278d1eb  2014-10-07 20:43:11 +1100  Defined monoid foldr macro
f89bd39  2014-10-07 17:57:26 +1100  BUG FIX: nodeType assumed list literals were not empty
73939ea  2014-10-07 17:30:04 +1100  BUG FIX: valid_value was not being asserted correctly for the last values
8aa9235  2014-10-07 12:46:10 +1100  BUG FIX: wasn't rendering functions passed to macros
9a928d7  2014-10-07 16:52:51 +1100  Patch 7 of 7: Converted listIn_Req and processingValues to Mealy FSMs. This reduces the start-up latency from 4 cycles to 2.
b59a5af  2014-10-07 12:32:48 +1100  Patch 6 of 7: Updated BoundedEnum to support the parallel list interface
c138a2f  2014-10-07 11:19:06 +1100  Patch 5 of 7: added parallel list support to defineNode
28d8146  2014-10-07 11:05:23 +1100  Patch 4 of 7: Implemented parallel mapping
122cdb0  2014-10-07 10:23:31 +1100  Patch 3 of 7: added checks for operators lacking parallel list support
c3c55c5  2014-10-07 10:19:48 +1100  Patch 2 of 7: added parallelism parameter to renderBuiltin
d37d099  2014-10-07 10:09:15 +1100  Patch 1 of 7: added parallel list support to renderArg
c71494e  2014-10-07 12:32:15 +1100  BUG FIX: chopComma assumed the presence of a comma
960a7e5  2014-10-07 09:34:40 +1100  Defined test cases for parallelism inference. Note that these are equivalent after inference has been performed.
fcdbe58  2014-10-07 09:33:37 +1100  Implemented parallelism inference (in both directions).
01b9301  2014-10-07 09:32:15 +1100  Changed Parallelism to not use record syntax. This allows us to define the value of NoPar as 1.
8094f25  2014-10-07 08:17:56 +1100  Removed obsolete comment - this was fixed by checkArgs
fa051b9  2014-10-06 11:08:35 +1100  Added parallelism attribute to DNode
4d41b2e  2014-10-04 21:22:31 +1000  Defined parallelism operator
5cb2244  2014-10-04 21:31:47 +1000  Moved functions to correct section
4f28345  2014-10-04 18:38:20 +1000  Fixed import issue with H2V_Compat
4a008ab  2014-10-04 00:39:15 +1000  Fixed some warnings in the testbench
726e3f6  2014-10-04 00:35:31 +1000  Test case for maps now working
41c32b1  2014-10-04 00:35:10 +1000  BUG FIX: map would only output a single value
fb19a78  2014-10-04 00:33:57 +1000  BUG FIX: done signals for lists are now generated appropriately
66f6934  2014-10-04 00:33:02 +1000  Revert "BUG FIX: added lambdas to rendering list"
74322fa  2014-10-04 00:32:07 +1000  Whitespace fixups
c271abb  2014-10-03 23:56:16 +1000  BUG FIX: Removed duplicate definitions of done signals
02e1787  2014-10-03 23:33:34 +1000  BUG FIX: added lambdas to rendering list
af38c5f  2014-10-03 23:31:40 +1000  Refactoring: defined isBuiltinMacro
c1367b8  2014-10-03 23:31:05 +1000  BUG FIX: nodeType didn't consider lambdas
cadab03  2014-10-03 22:59:34 +1000  Added support for rendering maps TODO: render associated lambdas
82d0a53  2014-10-02 21:00:19 +1000  Integrated ListMinAvail into the Decons operator's result. This results in much cleaner code, and is needed in order to handle the recursive case well.
1aaa3ae  2014-10-02 20:46:43 +1000  BUG FIX: didn't update dfold, dmap to traverse through tuples
fa012ab  2014-10-02 19:45:21 +1000  tests: head and tail (decons pattern binding) now work
f4af2d0  2014-10-02 19:44:01 +1000  BUG FIX: Added ready signal to ListMux, so that access is only granted after cond has propagated
526c6d2  2014-10-02 19:43:12 +1000  BUG FIX: Decons needs to deassert REQ before transferring control of the list, otherwise a new request will not occur
692a60d  2014-10-02 18:57:58 +1000  Added support for decons in subdeclarations
e71ef42  2014-10-02 18:52:17 +1000  BUG FIX: req and ack have opposite assignment directions
d84dafe  2014-10-02 18:21:54 +1000  BUG FIX: ListMux was defined the wrong way around
f239f01  2014-10-02 18:20:07 +1000  BUG FIX: empty list literals still need to track lastReq
161a07d  2014-10-02 18:06:09 +1000  Refactoring: added newlines to cleanup generated code
6c508e4  2014-10-02 18:01:45 +1000  BUG FIX: removed inferred latch
17b2a06  2014-10-02 17:54:07 +1000  Explicitly named module instances
4bcb598  2014-10-02 17:53:56 +1000  Added definitions for implicit signals (removes warnings)
107596d  2014-10-02 17:29:19 +1000  Removed trailing commas
842d86a  2014-10-02 17:24:08 +1000  BUG FIX: functions can return lists
7c2de3d  2014-10-02 17:04:46 +1000  Refined logic for root definitions to not exclude unnecessary lines
5ae2786  2014-10-02 04:16:51 +1000  Made VNodeDef showable to facilitate debugging
9fb60b6  2014-10-02 03:36:48 +1000  Fixed done signals - weren't being generated for lists in some cases
de95a89  2014-10-02 03:32:18 +1000  BUG FIX: variables should be assigned the same type as their value
20cc87f  2014-10-02 02:16:35 +1000  BUG FIX: ternary statement assumed values were scalars
d054b35  2014-10-02 02:03:43 +1000  BUG FIX: should check the function signature instead of inferring type from root node, as it is more reliable Since type signatures aren't always available, fallback to type inferrance otherwise.
cce4af7  2014-10-02 01:58:02 +1000  Modified makefile to simplify testing
8ae98ce  2014-10-01 00:47:09 +1000  Added testcase for head
89356ce  2014-10-01 00:46:35 +1000  Created a second testbench module for scalar tests
7e71784  2014-10-01 00:39:29 +1000  BUG FIX: Fixed done signals
67a72ee  2014-09-30 23:52:51 +1000  Patch N of N: fixed decons implementation
d72fd5c  2014-09-30 23:18:11 +1000  Implemented Decons, ListMinAvail (WIP)
ecee6bb  2014-09-30 22:03:20 +1000  Refactoring: added extended versions of functions to facilitate tuples
1e11144  2014-09-30 20:24:01 +1000  Refactoring: added field to RecursiveCase for list items consumed
bf2897b  2014-09-30 19:37:19 +1000  RenderVerilog: added check for recursive function which produces a list
8295310  2014-09-30 19:36:55 +1000  Added tuple support to RenderGraphviz (consumption only)
452e000  2014-09-30 19:30:53 +1000  Refactoring: replaced ListNotEmpty with ListMinAvail. This handles the case where a function consumes multiple elements from the list at once.
ed0db17  2014-09-30 18:20:27 +1000  Patch 5 of N: added tuple support to RenderGraphviz
9f46083  2014-09-30 18:11:47 +1000  Refactoring
2cf8237  2014-09-30 18:11:32 +1000  Added pattern matching code for lists
16682fc  2014-09-30 17:50:25 +1000  Patch 0 of N: added test case
8bc2094  2014-09-30 17:22:18 +1000  Patch 4 of N: added internal tuple support. Needed to enable decons to return 2 values
010ea5c  2014-09-30 17:21:23 +1000  Patch 3 of N: Refactored defineDecl to facilitate the definition of multiple nodes per declaration. Needed for destructuring.
ad6020f  2014-09-30 16:45:00 +1000  Patch 2 of N: Added name extraction for tuple-patterns
25729fd  2014-09-30 16:28:34 +1000  Patch 1 of N: added pattern destructuring for cons opreator
709a310  2014-09-30 16:46:51 +1000  BUG FIX: was defining concat with the wrong type
667d31f  2014-09-30 16:44:05 +1000  BUG FIX: createDfdHeaders returned an uninformative error message
89c0e21  2014-09-30 00:10:11 +1000  BUG FIX: parsing library has the wrong associativity for the cons operator
b82fbce  2014-09-29 22:59:08 +1000  Changed list protocol to use value_valid instead of eol (fully tested). This delays termination signal until after the non-existent element has been requested. It simplifies some code and generalizes to the parallel case more easily.

================================================================================
Thursday 25 September 2014
Fully implemented and debugged list operators. Modified list protocol to
require REQ to be reset and reasserted between reads, since this greatly
simplifies the code.
(KNOWN BUG: cons operator doesn't work properly when nested.)
While map/reduce was not started, the non-parallel map/reduce code can be easily derived from the concat or cons
operator modules, since they also iterate over lists.

Aiming to complete parallel map/reduce next week. Given it is the midsem
break, it should be feasible to make significant progress.
Report & poster are due 2 weeks after midsem break, so it is important that
map/reduce is fully implemented by the end of it. Ideally will start on the
report/poster during the break as well.

Git commits:
441efde  2014-09-25 00:27:59 +1000  BUG FIX: done signals are only 1 bit wide
bc6a51a  2014-09-25 00:26:07 +1000  Labelled module instances to facilitate debugging
810bf66  2014-09-25 00:00:01 +1000  Testbench for cons operator
ada59a4  2014-09-24 23:59:41 +1000  Implemented cons operator
33ca56e  2014-09-24 23:02:48 +1000  Testbench for concat operator
fc01531  2014-09-24 22:58:40 +1000  Implemented concat operator
7b7912f  2014-09-24 22:07:57 +1000  Testbench for enum
7cf0f45  2014-09-24 22:07:37 +1000  BUG FIX: handle non-unit steps correctly Note that we are still limited to positive steps; negative ones would require a second generator module to be defined.
4577e20  2014-09-24 21:39:06 +1000  Testbench for range test
117dba9  2014-09-24 21:38:05 +1000  BUG FIX: enumerations now work
ff14bd0  2014-09-24 20:33:57 +1000  Testbench of listLiteral
ae3a15a  2014-09-24 20:33:44 +1000  Changed list protocol to only advance list on the positive edge of a request signal This was necessary to avoid the additional complexity of advancing for each cycle req was high after the ack.
608356a  2014-09-24 19:20:13 +1000  Replaced individual ready signals for list literals with a single one. This is more consistent with the pattern used for other modules, and allows us to request them in parallel instead of sequentially. It is also much simpler.
c279315  2014-09-24 19:17:13 +1000  Refactoring: renamed nodeID to listID to prevent shadowing Also fixed some whitespace
8d0a6e1  2014-09-24 19:12:17 +1000  BUG FIX: had directions reversed for list arguments
e37d512  2014-09-24 00:07:41 +1000  BUG FIX: prevent ack from being asserted outside of a request
c5dbe8d  2014-09-23 23:58:42 +1000  BUG FIX: always blocks should trigger on the *edge* of a clock signal only
dcb87c2  2014-09-23 23:57:17 +1000  Updated testbench for list tests
190a4b8  2014-09-23 20:53:09 +1000  Whitespace fix (to facilitate folding in vim)
047f5ed  2014-09-23 20:21:40 +1000  BUG FIX: Lists have their own protocol for communicating the validity of values, so we don't need to delay the done signal
e589250  2014-09-23 20:16:39 +1000  BUG FIX: need to check both sides of assign, since RHS is more likely to have type info
2c236c9  2014-09-23 20:11:52 +1000  BUG FIX: ignore definitions of ports which are defined as part of the module
17724a8  2014-09-18 16:21:35 +1000  Whitespace fix
eb07f69  2014-09-18 16:12:10 +1000  BUG FIX: removed trailing commas
acf513f  2014-09-18 16:12:01 +1000  BUG FIX: didn't define nodeType for ListLiteral
2def57f  2014-09-18 15:48:54 +1000  BUG FIX: elements of list literals were not being rendered
09177ef  2014-09-18 15:43:44 +1000  BUG FIX: ListLiteral did not have a ready signal
55ba8a7  2014-09-18 15:36:10 +1000  Added include.v
484ab5f  2014-09-18 15:35:29 +1000  Fixed syntax errors in generated Verilog
d30f47c  2014-09-18 15:19:58 +1000  Implemented Cons and Concat operators (client-side)
3b3c098  2014-09-18 15:08:36 +1000  Corrected typos
ec6131a  2014-09-18 01:01:06 +1000  Modified uploading script to open folder automatically.

================================================================================
Thursday 18 September 2014
Implemented support for rendering list code to Verilog.
Performed regression testing and eliminated associated bugs. (Generated code for all (non-list) tests is equivalent to output from last week's code.)
Need to write Verilog modules for enums (trivial) and test the list code.
Should be able to start on map/reduce code this week.

Git commits:
5a456e6  2014-09-18 00:29:00 +1000  Defined getConstant (preliminary)
b7d2da8  2014-09-18 00:43:59 +1000  BUG FIX: Forgot to remove the constraint from the generalised code
5f72e07  2014-09-18 00:28:05 +1000  BUG FIX: was generating extraneous done declarations
4e43362  2014-09-18 00:27:45 +1000  BUG FIX: was omitting newlines
a1637dc  2014-09-18 00:50:31 +1000  Patch 3 of 3: Verilog List Support Implemented enumeration logic.
fa5d64d  2014-09-18 00:49:36 +1000  Patch 2 of 3: Verilog List Support Refactored function call code to work with lists
9b658cf  2014-09-17 23:15:53 +1000  Patch 1 of 3: Verilog List Support Refactored node definition/assignment logic into separate functions
5ea1acc  2014-09-18 00:53:24 +1000  Created an include directory to hold Haskell and Verilog dependencies
41d941d  2014-09-18 00:33:26 +1000  Added Verilog compilation to test script
1d4ca1a  2014-09-17 21:16:37 +1000  Whitespace fixups
92ce16f  2014-09-14 21:46:15 +1000  Added support for rendering list literals to Verilog
4afc949  2014-09-14 21:44:18 +1000  Refactoring: added printfAll, since it simplifies a common pattern
b0a3349  2014-09-14 20:17:59 +1000  Refactoring: added vModDeps to VNodeDef, so that we can define modules on a per-node basis
f9f345b  2014-09-14 19:51:14 +1000  Removed obsolete comments

================================================================================
Wednesday 10 September 2014
Syntax and DFD level support for lists is now complete, including rendering to Graphviz.
Now working on Verilog level support.

Git commits:
2f5b105  2014-09-10 20:37:57 +1000  Added Graphviz rendering support for lists
5bd7a90  2014-09-10 20:57:28 +1000  Added DFD support for enumeration literals.
088fd4f  2014-09-10 20:21:51 +1000  Added DFD support for list literals
6c6b50c  2014-09-10 20:14:21 +1000  Added definitions for cons and concat builtins.
6f813c0  2014-09-10 20:10:45 +1000  Refactored the definitions of built-in functions, so that they're actually readable.
8133c0d  2014-09-10 20:16:18 +1000  Added basic syntax support for lists.
cf5ab3b  2014-09-10 20:15:15 +1000  Refactored code for generating AST identifiers into a convenience function.

================================================================================
Thursday 04 September 2014
Higher order functions are now fully debugged (this took a surprisingly large amount of time for such a small amount of code).
Also moved each test case into a separate file, since the DFD was getting quite crowded.
Now starting work on list support.

Git commits:
fedee53  2014-08-30 16:15:48 +1000  Moved exclusion of higher order functions to DFD code from rendering, since it's common to both
c2fb6d2  2014-08-30 15:59:33 +1000  Rewrote test, since we don't support dependency resolution for higher order functions
33c0556  2014-08-30 15:56:43 +1000  BUG FIX: Commit d957bb (Combined macro eval code) broke recursive functions. This makes higher order and recursive functions mutually exclusive.
ed6066d  2014-08-30 15:32:03 +1000  Moved tests into a dedicated folder
1555210  2014-08-30 13:06:46 +1000  BUG FIX: function calls with the correct no. of args can still return functions if the function called is higher order
226ec40  2014-08-30 13:05:19 +1000  BUG FIX: subArgs was only replacing scalar nodes, not functions This facilitates higher order functions which take functional arguments
cfff239  2014-08-30 12:06:01 +1000  Fixed type signature parsing logic
d882846  2014-08-29 22:17:16 +1000  Added HsAlign.d to facilitate debugging
a7fbe5f  2014-08-29 17:58:41 +1000  Implemented support for partial application
f94fddb  2014-08-29 17:57:21 +1000  Added support for partial application of operators (AST rewriting)

================================================================================
Thursday 28 August 2014
Have partially achieved higher order function support, but more work is needed.
Most of the issues this week have stemmed from problems handling type signatures correctly, or bugs in the rendering code.

Test case for returning a function works, but not for accepting a function as an argument (which is the important one).
Haskell type signatures are trees of signatures, where a scalar type is a leaf node. A node of height n is a (n + 1)th order function. .e.g a leaf is 0th order, (a -> b) is 1st order, (a -> b) -> c and a -> (b -> c) are both 2nd order. i.e. a function of n + 1 arguments is effectively an nth order function.
It is also worth noting there is no syntactic difference between a -> b -> c and a -> (b -> c).
Therefore, in order to handle the general case appropriately, we need to treat functions which return functions as if they have extra parameters, and then interpret the lack of those parameters as partial application. Otherwise, it will be impossible to correctly handle arguments which are functions.

Git commits:
060b48c  2014-08-28 11:16:06 +1000  Defined nullSrcLoc
6b688d4  2014-08-28 11:14:57 +1000  Added test cases
722d747  2014-08-28 09:58:05 +1000  Added support for the function application operator ($)
6b9fc34  2014-08-25 22:37:02 +1000  Modified test case to include multiple calls to the same higher order function
92dae60  2014-08-25 22:36:14 +1000  Added dfd IDs to output labels to facilitate debugging
d4197ad  2014-08-25 22:30:51 +1000  Disabled rendering of higher order functions, since we don't use them at runtime
17e6d28  2014-08-25 22:30:35 +1000  BUG FIX: each instance of a lambda should have a unique id
928e464  2014-08-25 22:30:20 +1000  Renamed defineLambda to better reflect its purpose
91fb6ab  2014-08-25 22:24:47 +1000  BUG FIX: was not cloning nodes correctly
80d32bb  2014-08-25 21:40:57 +1000  Graphviz: Added node IDs to argument nodes to facilitate debugging
6dde353  2014-08-25 20:48:27 +1000  Renamed variables to better reflect what they're doing
66bb8a6  2014-08-25 20:36:46 +1000  BUG FIX: we were having collisions between definitions of the result node, so let's just give it a unique definition and point it to the root node
7944b60  2014-08-25 20:35:29 +1000  BUG FIX: was assigning the same ID to DFunctions as the enclosed DFDs
949b77c  2014-08-25 19:57:02 +1000  Added more specific targets for testing, and fixed a corner case in main
036c611  2014-08-25 00:00:35 +1000  BUG FIX: was conflating the IDs of the DFD and its root node
e947cb6  2014-08-24 23:42:12 +1000  Added basic test case for higher order functions
d957bb9  2014-08-24 23:41:15 +1000  Combined macro evaluation code with linking code, since it fits better there
d8cb422  2014-08-24 23:15:05 +1000  BUG FIX: function args in type signatures are folded on the left; a function type on the right indicates a higher order function
c38c42c  2014-08-24 22:32:30 +1000  Refactored DFD type so that we can use the same accessor functions for both DFD and DfdHeader
ea1adbf  2014-08-24 19:31:16 +1000  BUG FIX: Added missing case to resolveFunc
6ae9a7a  2014-08-19 23:17:51 +1000  BUG FIX: upload script contained wrong URL

================================================================================
Tuesday 19 August 2014
Implemented macro evaluation, fixed some related bugs. There is currently a
bug where lambdas are returned instead of being called - in the process of
debugging this now. (See test.png)

Git commits:
553bbab  2014-08-19 22:38:36 +1000  Added support for printing DFD
a4d64e2  2014-08-17 03:19:33 +1000  Added node IDs to Graphviz output, to facilitate debugging
ce6b4ed  2014-08-17 03:01:28 +1000  BUG FIX: defineTypedArg was not pushing functions on the namespace stack
a7188fd  2014-08-17 03:00:35 +1000  BUG FIX: resolveFunc was not handling functions inside variables correctly
17b91ca  2014-08-17 02:59:46 +1000  BUG FIX: isHigherOrderFunc was missing a case
2fdb03a  2014-08-17 02:31:24 +1000  Implemented higher order functions via macro evaluation
5a152f2  2014-08-14 14:34:05 +1000  BUG FIX: upload script assumed that there were no other tar archives present

================================================================================
Wednesday 13 August 2014
Attempting to use the fledgling closure code proved unsuccessful. Closures and higher order functions are sufficiently different that they are best handled separately.
I have decided to pass signals from functions, instead of evaluating them at compile-time. This is because compile-time evaluation is harder than originally predicted, and will make it almost impossible to handle user defined higher order functions. It is best handled as an optimization later, if necessary. This imposes the constraint that the result of a higher order function can only be called at one point in its function.

I have decided to require type-signatures for higher order functions, due to syntactic ambiguity. e.g. it cannot be determined whether
    f = foo x
returns a value or a function without knowing the type of foo. Since introspection of foo would be difficult, it is much easier to simply require foo has a type signature. Code for processing type signatures has been implemented.

Rendering of higher order functions in Verilog is currently a work in progress.

Git commits:
67bd0bc  2014-08-13 23:27:22 +1000  Revert "BUG FIX: give priority to functions" This breaks first-order functions.
a0721e9  2014-08-13 23:17:27 +1000  Changed header generation to use information present in the type signature, if available
8c058a7  2014-08-13 22:49:12 +1000  Added code to collect types from signatures and store them in the headers
88fb7d9  2014-08-13 22:48:14 +1000  Added support for collecting type signatures and matching them to functions. TODO: use these to define headers and identify higher order functions
abd2ec4  2014-08-13 21:26:03 +1000  Modified test case to explicitly use a functional alias
4e370a9  2014-08-13 21:25:22 +1000  Added Graphviz rendering support for lambdas
924245c  2014-08-13 21:12:29 +1000  BUG FIX: pattern bindings aren't necessarily CAFs
2f67192  2014-08-13 21:12:01 +1000  BUG FIX: resolveFunc wasn't checking the node namespace
f654bd0  2014-08-13 21:11:35 +1000  BUG FIX: give priority to functions This is only a short-term solution; we really should be keeping both nodes and functions in the same namespace
e03ad1f  2014-08-13 21:09:35 +1000  Refactored defineDecl so that nodes can exist in both namespaces.
a47e297  2014-08-12 22:09:42 +1000  Added support for lambda functions
72b7e59  2014-08-12 22:07:35 +1000  Created resolve(), and refactored resolution logic to have pure and impure variants. Catching exceptions can only be done in the IO monad, which is complex as resolution must be performed in the NodeGen monad. Splitting the code for throwing exceptions and performing resolution fixes this.
f76059e  2014-08-12 22:08:14 +1000  Added test case for higher order functions
794f622  2014-08-12 20:12:30 +1000  Temporarily removed closure test case

================================================================================
Wednesday 06 August 2014
Fixed issue with done signal using SignalTap (couldn't get ModelSim to work).
Attempting to get closure rewriting working before higher order functions, because they both involve the same kind of expression rewriting. Have rebased an experimental topic branch from May and making headway on it. (Compare test-master.png and test.png.)

Current state of closure rewriting:
f2c: both definition and call is correct
f2b: redef'd correctly, missing an arg (node_4)
f2a: some references are not being updated correctly. Also, the Graphviz rendering code is buggy
possible issue: what if a subgraph moved into a different scope contains an expression that needs to be rewritten?

Ideas for block diagram:
-each function is a box
-each box contains a graph representing parallelism. e.g. maps are expanded into a column
-function calls are shown as boxes
-all other expressions not shown, in order to simplify rendering (they're combinatorial anyway, so they can be neglected)

NOTE: parallel folds require monoids. i.e. an associative function and its identity. The built-in notation for this is a pain, so we should probably define a foldP that makes it easier to do this as a one-liner.
http://en.wikibooks.org/wiki/Haskell/Monoids

How to create a Modelsim simulation:
-right click on module -> Create Wave
-delete the output signals; only input signals should begin with 'Edit:'
-right click on the input signals and click Edit -> Create/Modify Waveform
    -define the input signals. If you switch to Edit mode, you can select and invert specific parts of the signal
-drag the output signals from the object window into wave window. They will begin with the prefix 'sim:'
use the command 'run -all'
-ISSUE: the output signals are shown as being undefined/'XXXXX'
-WORKAROUND: using SignalTap instead.

Git commits:
f012700  2014-08-06 23:35:53 +1000  Modified update-journal.sh to be non-interactive.
29301f8  2014-08-06 22:54:18 +1000  BUG FIX: we can't assume that the only nodes in the closure are variables
c701b37  2014-05-19 19:48:10 +1000  WIP: Closure support Code is mostly complete, but needs to be debugged. Leaving on a topic branch until I have enough time to do this properly.
d33bd20  2014-05-19 19:47:12 +1000  Function definition rewriting code
2198b5f  2014-05-19 20:02:27 +1000  Enabled closure rewriting
86686b6  2014-08-03 16:36:38 +1000  Added generated file to gitignore
2eb3f49  2014-08-03 16:34:50 +1000  Added testbench module for use with SignalTap, because unlike ModelSim its actually usable.
21caa5e  2014-08-03 16:30:42 +1000  BUG: done signal was late by one period, as it was being incorrectly clocked. Also renamed running to wasReady, since it's just ready delayed by a cycle.
4bfe819  2014-08-03 16:24:39 +1000  Removed less invocation from makefile

================================================================================
Meeting notes:
-to use Modelsim, go Tools -> Waves, add signals, then use the command 'run 1000ns'
-need to generate a decent block diagram, which shows parallel constructs, sequential loops, etc.
-should research pipelining DFDs
-loop unrolling is pointless for seq logic - it's only applicable to map-reduce
-add examples of higher order functions to journal/email to David

-TODO: finish ready/done signals, higher order funcs -> lists -> DMA

================================================================================
Wednesday 30 July 2014
Simulated and debugged Fibonacci generator test case (see Functional-Sim.vwf). Now working, apart from some minor issues.
There is currently a bug where the value of the done signal lags the expected value by 1 clock cycle.
There also seems to be some slight weirdness with the function not resetting correctly.

Using ModelSim via Quartus' Simulation Waveform Editor, since it is *much* easier to use.


Git commits:
ad279f2  2014-07-30 23:36:26 +1000  Updated journal uploading script
09688ed  2014-07-30 23:32:35 +1000  Added Quartus project used for simulations
445442f  2014-07-29 16:25:48 +1000  Partially implement ready/done signalling. Need to do this for the cases of a recursive function later.
f276e78  2014-07-29 15:17:18 +1000  BUG: We were performing an extra iteration since done lagged by one cycle (Also, we weren't ceasing iteration at all).
d7031be  2014-07-29 15:10:47 +1000  BUG: ready/done signals were disconnected
fba63f7  2014-07-29 15:10:27 +1000  BUG: If we're not recursing, we need to set done to stop iterating
fc640da  2014-07-29 11:45:14 +1000  Makefile: disabled profiling
cf86b06  2014-07-23 22:13:07 +1000  Modelsim assumes implicit nets are 1 bit wide, so we need to define them explicitly.
7a42a20  2014-07-23 22:02:48 +1000  Refactored VNodeDef into a record, since we need to store definitions and assignments seperately.
aeb767b  2014-07-23 20:59:03 +1000  Refactored VNode extraction logic into a separate function
1a71de9  2014-07-23 20:45:45 +1000  Modelsim requires modules be defined before they are used This corrects the generation of recursive functions. Still need to fix the generation order of regular functions
94f020a  2014-07-23 20:32:28 +1000  Modelsim treats unnamed modules as an error, so give them names.
d67100b  2014-07-23 20:39:50 +1000  Removed obsolete comment
2e35e6d  2014-07-23 18:34:10 +1000  BUG FIX: mixed up indices
b43232a  2014-07-21 22:15:52 +1000  Added an explicit default branch with don't cares to prevent latches from being inferred.
3a988dd  2014-07-21 21:58:33 +1000  Modified code to use an implicit sensitivity list (less error prone).
e404804  2014-07-21 21:34:18 +1000  BUG FIX: wasn't actually checking the value of useNodeId
7948f4e  2014-07-21 21:33:48 +1000  BUG FIX: different recursive cases may share DFD subgraphs, so we need to return VNodeDefs
28aa0fd  2014-07-21 20:10:42 +1000  Added some newlines for readability
328327c  2014-07-21 19:57:17 +1000  BUG FIX: mixed up the input and output args
3e9e6cc  2014-07-21 19:53:17 +1000  Corrected generated combinatorial modules so that they were actually combinatorial (i.e. not clocked). Note that the reg keyword must be used for any output variable set via an always block (but not via assign). Also refactored the muxing logic to be cleaner.
3306835  2014-07-21 19:05:57 +1000  Corrected typo
982f22b  2014-07-21 19:00:43 +1000  BUG FIX: DFD and Node IDs exist in separate namespaces, so we can't just use the DFD ID to describe the result node
fba9dae  2014-07-21 18:52:04 +1000  BUG FIX: mixed up semicolons and commas
a388b5a  2014-07-15 23:01:21 +1000  Corrected formatting errors in generated Verilog
d561871  2014-07-15 23:00:55 +1000  Changed Makefile's test target, since we're now focusing on Verilog
c0c75cd  2014-07-15 21:51:57 +1000  BUG FIX: removed code performing testing for indirect recursion, since it was buggy and only used to check for error conditions.
100c2da  2014-07-15 21:40:20 +1000  BUG FIX: mixed up which was supposed to be true
7dd7f8d  2014-07-15 21:38:56 +1000  WIP: Added code for handling recursive cases (assumes combinatorial case selection)
c585aa8  2014-07-15 21:37:12 +1000  Refactored Verilog rendering code to use a typedef for the recursive case record
897147e  2014-07-15 21:35:29 +1000  Added definitions for isLeft, isRight, because GHC can't find them
56fcb2b  2014-06-02 00:05:08 +1000  WIP
c707988  2014-05-31 23:13:47 +1000  Implemented logic for detecting recursive functions.

================================================================================
Note: projector is 1280x1024
There's an absolutely fantastic reference here that I should read sometime:
    http://www.jucs.org/jucs_11_7/hardware_design_and_functional/jucs_11_7_1135_1158_sheeran.pdf


TODO: create mock up of how the power method would look, and what the structure of its Verilog would look like
-also consider finding something that doesn't need square roots
-Taylor series approx of square root could work quite well, as long as we handle the exponents in a sane way
    Probably should just implement the square root function in Verilog, because it's not going to map nicely to Haskell

================================================================================
Wednesday 28 May 2014
Have mostly completed draft of design report, except for some minor additions.

Summary of points from email (to be discussed in meeting):
-benchmarks / test functions with Verilog, DFDs, discussion, etc. - to be added later today
-expected difficulties - main one would be insufficient time for all of the optimizations. Have already marked QSys integration to be dropped if this is the case - should I discuss this more clearly?
-code excerpts for core features (C, Haskell, Verilog, block diagrams) is a good idea, but there is probably not enough time to get it done in time for the report
-RE: listings 1 and 2, I have added a block diagram and reworded the discussion
-looking at other HDL generating tools is a good idea, but definitely something to think about later.

Git commits:
a2fced1  2014-05-28 03:57:10 +1000  Minor bug fix
e674e8b  2014-05-28 03:32:58 +1000  Added block diagram to demonstrate parallel mapping.
138c996  2014-05-28 02:45:59 +1000  Added some example code to demonstrate parallel list processing.
e918930  2014-05-28 01:44:10 +1000  Added source code to design spec, defined syntax highlighting rules
270e7f4  2014-05-28 01:41:48 +1000  Added diagrams
cd4d8eb  2014-05-27 03:14:03 +1000  Completed draft of design spec. Need to add diagrams, fix citations.
3a297a1  2014-05-26 02:27:54 +1000  WIP: Design Spec - up to 1.4. Using Latex.

================================================================================
Notes on C2H:

http://www.altera.com/literature/ug/ug_nios2_c2h_compiler.pdf
-C to hardware mapping: [pg 17]
    +"The C2H Compiler translates each element of C syntax to an equivalent
      hardware structure using straightforward mapping rules. The mapping
      rules provide a one-to-one association between elements of C syntax and
      their equivalent hardware structures." - pg. 41, implies the limitations of C syntax are significant
    +loops become state machines (subject to pipelining)
    +pointer dereferences, array accesses are direct reads (via avalon); no caching
    +each function is only mapped to a single hardware instance (per top-level function) [pg 52]
    +no inline functions; how you organize the code affects the generated logic [pg 53]
    +structs/arrays are stored in memory, and only one field/element can be accessed per cycle. Local arrays/structs do not consume memory, but still use Avalon bus and are therefore still limited to one element per cycle [pg 54]
    +global/static variables are passed in as pointers; access is expensive
    +generates one Avalon master for *each* memory access operation - can result in *significant* bottlenecks memory-side
    +memory aliases introduce false dependencies; write operations via pointer/array must be completeted before subsequent reads from *any* memory location. This can be corrected with __restrict__, but is easy to forget or apply incorrectly. [pg 76]
    +functions are represented as sequential state machines; unrelated computations placed in the same state mean that one computation can block another. Cf H2V, where functions are represented as the propagation of data. [pg 81]
    +C2H has loop pipelining, but because it uses single port Avalon-MM it cannot implement loop unrolling.

-C2H does not support recursion
-C2H does not replicate side-effects correctly. e.g. short-circuit operators [pg 128]
-many of the recommended practices for C2H are syntactic requirements of functional languages (e.g. replacing global variables with arguments)
-do a speed comparison between H2V and C2H for trivial functions - it is likely that C2H is significantly slower
-more control over integer widths - C2H only provides ANSI C types (8, 16, 32, 64)
-each assignment is registered; implies significant increase to CPI [pg 43-44]
    +this is done to increase pipelining, but is excessive
    +the placement of registers is fixed with respect the syntax [e.g. pg 48-49]. This is inferior to dividing nodes following a timing analysis

TODO: need to add code to flush data cache to wrapper function, to avoid cache coherency issues
TODO: mention endianness (Nios uses little endian)

paradigm example: for loop vs map

================================================================================
Wednesday 21 May 2014
Have postponed closure support, as it is non-essential and taking longer than expected to debug.
Graphviz generation of nested (non-closure) functions now works - refer to H2V/test.png.
Preliminary Verilog generation is working (see H2V/test.v). Currently only combinatorial functions are supported, and we guess the type a lot. However, it does synthesize correctly in Quartus.
Need to extend module definitions to include start/done signals for synchronous functions.
Generation of Verilog for recursive functions fails due to a linking bug - need to fix this later.
Wrote a rough plan for the design spec, will be expanded upon over the next week (due Wed 30).

Git commits:
master branch:
95cae44  2014-05-21 00:41:16 +1000  Wrote rough plan of design specification.
3131219  2014-05-20 00:19:55 +1000  BUG FIX: changed 'if' from BinaryOP to Ternary. Added DBool type.
694474c  2014-05-20 00:19:04 +1000  Preliminary Verilog generation
664aec7  2014-05-19 23:03:49 +1000  Rewrote Graphviz rendering code so that all nodes are defined before edges, to ensure that they are placed in the correct functions.
70dc45e  2014-05-19 22:01:23 +1000  BUG FIX: dmap, etc. were not recursive
fdbd7a5  2014-05-19 20:41:09 +1000  BUG FIX: Built-in functions should not be rendered
a299409  2014-05-19 19:53:00 +1000  Fixed collectedDfds to handle recursive functions.
ba5b112  2014-05-19 19:45:02 +1000  Helper functions
9ce1164  2014-05-19 19:42:46 +1000  Added code for identifying foreign nodes
993c202  2014-05-19 19:41:59 +1000  Added code for collecting nested functions. (Part 1)
9b3047a  2014-05-17 18:03:30 +1000  Refactored logic for mapping/folding over the DFD into separate functions.
6f13afd  2014-05-16 22:03:06 +1000  Created a CLI, and a template file for Verilog generation.
3d9b668  2014-05-16 22:00:16 +1000  Added brackets to quadratic test case as a workaround for a haskell-src bug

closures topic branch:
cb73f3f  2014-05-19 19:48:10 +1000  WIP: Closure support Code is mostly complete, but needs to be debugged. Leaving on a topic branch until I have enough time to do this properly.
30563d2  2014-05-19 19:47:12 +1000  Function definition rewriting code
427a87e  2014-05-19 20:02:27 +1000  Enabled closure rewriting
a299409  2014-05-19 19:53:00 +1000  Fixed collectedDfds to handle recursive functions.

================================================================================
Notes from meeting of 14-05-2014:
For Verilog generation of recursive functions, let there be a synchronous
module which handles recursive logic, and a combinatorial module that
implements actual logic. This will greatly simplify loop unrolling.

GOAL: generate synchronous Verilog in time for presentation.e.g. Fibonnacci
sequence. Also implement eigenvalue power method.
Include block diagrams of expected Verilog output for recursive functions in
design report.

Presentation should focus on what it will be able to do, as opposed to what it
can do.

================================================================================
Wednesday 14 May 2014
Implemented DFD generation for nested and recursive functions.
Preliminary Graphviz generation is now implemented - see H2V/test.png for an example of this.

Note that f3 does not render correctly because f2c relies on a closure. (Also,
nested functions aren't being rendered anyway.) Currently working on rewriting
closures as function arguments, but this logic is surprisingly complex.

The logic for collecting nested functions and performing closure rewriting has
been combined, since both require a traversal of the DFD to find functions.

Git commits:
ac6ad64  2014-05-13 23:59:21 +1000  WIP: closure rewriting
c287678  2014-05-13 23:53:45 +1000  Added nodeChildren, since it's a fairly common operation.
c5809d1  2014-05-13 23:53:14 +1000  Added some general purpose monadic methods to Common.
05c7bfe  2014-05-13 19:55:33 +1000  Added function list to state monad
68c1244  2014-05-12 22:45:41 +1000  Renamed resolveIdDFD to resolveHeader, since it facilitates better error messages
d54c008  2014-05-12 22:34:56 +1000  Refactored DFD and DNode to use record syntax, as it simplifies some expressions.
c2d338e  2014-05-12 21:43:39 +1000  Added some headings to DfdDef
f814d98  2014-05-12 21:32:00 +1000  Refactored NodeGenData into a record, since this enables neater syntax and allows fields to be added/removed more easily.
37de45d  2014-05-12 20:08:25 +1000  BUG FIX: where the data path forked and merged, nodes were being defined multiple times
c0ef5da  2014-05-12 20:07:36 +1000  Added list of arguments (and their types) to function definition.
d71a3e9  2014-05-11 19:34:34 +1000  Added an explicit type for use when type has not been specified.
12a86cc  2014-05-11 19:27:07 +1000  WIP: Graphviz generation. Nested functions are not rendered. Need to add no. of args to DFD.
78ee0cc  2014-05-11 17:50:32 +1000  Changed function linking to use UIDs instead of names. This avoids issues related to shadowing.
b6914cb  2014-05-11 17:25:56 +1000  Added support for nested, recursive functions.
954bd20  2014-05-11 15:58:19 +1000  Improved DFD resolution error messages to specify which functions are only headers.
47e829e  2014-05-11 15:48:14 +1000  Merged createDFD into defineDecl(HsFunBind). defineDecl now returns both nodes and DFDs, which is handled by popNS/pushNS. This enables nested functions.
0414b5a  2014-05-11 14:48:35 +1000  Added test case for nested functions
44177a3  2014-05-11 14:48:00 +1000  Moved language extension flags into Makefile
056bbc1  2014-05-11 14:21:16 +1000  Added logic for defining function headers before functions. This is used by recursive functions.

================================================================================
Wednesday 07 May 2014
DFD generation code is now almost completely functional. Implemented data
dependency resolution code, so that variables and functions can be defined in arbitary
order.

Nested functions are not yet implemented (requires adjustments to dependency
resolution to handle closure correctly). Recursive functions are also
currently not functional, since they refer to themselves before they are
defined. Both of these require only minor fixes.

Graphviz generation (and possibly Verilog) should be attainable by next week.
Report is due Wed 28 May, so should probably start that soon. (Presentation is
due the week after.)

Git commits:
21c170b  2014-05-06 19:23:00 +1000  BUG FIX: Since the namespace is stored as a stack, we need to pop in reverse order.
cf872a0  2014-05-06 19:22:14 +1000  Reduced verbosity of node resolution error messages, since all we care about are the names.
fd16aea  2014-05-06 19:21:38 +1000  Added tShow to Common. Useful when debugging.
b59bb06  2014-05-06 19:01:42 +1000  Refactored namespace storage to use 1D lists, since we never push more than one element at at time.
1876d7c  2014-05-06 19:00:48 +1000  BUG FIX: We now push declarations to the namespace immediately on creation. This is necessary so that
b700339  2014-05-06 20:16:55 +1000  Added test case for dependency resolution
3de1198  2014-05-03 10:48:31 +1000  Added dependency resolution code so that declarations are evaluated in the correct order.
534be5a  2014-05-03 10:12:55 +1000  Implemented a custom exception for node resolution failure. This was originally going to be used for try-catch structures, but is now used only to format error messages.
e251e5f  2014-05-03 03:39:37 +1000  WIP: Part 1 of arbitrary term definition order
1fb90d2  2014-05-03 01:38:15 +1000  Refactored prelude definitions
70bc6e7  2014-05-03 01:37:47 +1000  BUG FIX: was using an unsanitised version of the arguments from the first match, which could include patterns

================================================================================
Wednesday 30 April 2014
Encountered a temporary set-back related to a GHC bug where undefined
typeclass members could result in stack overflows. Found a workaround, but
spent most of the break doing doing so.

DFD generation code is slowly underway - implementing support for expressions one at a
time as required by test case (Fibonacci sequence).

The minimal implementation may be larger than expected due to
interdependencies. e.g. pattern matching requires if statements, which require
the ability to import functions from Prelude. However, this does not change
the overall implementation time because these features would need to be
implemented sooner or later anyway.


Git commits:
83108f4  2014-04-30 00:56:52 +1000  WIP: adding support for IF statements
93b515e  2014-04-30 00:58:22 +1000  TEMP: Changed test.hs so that functions are in strict dependency order. Revert once we have better dependency resolution
4c6c526  2014-04-29 02:42:53 +1000  Added support for let statements, function application.
336a832  2014-04-29 02:41:54 +1000  Preliminary: added some basic definitions of built-in operators
2497610  2014-04-29 02:40:53 +1000  Added utility methods for converting qualified names to strings, removed stale code.
770ce6f  2014-04-29 02:38:45 +1000  BUG FIX: State modification code was commented out
4139525  2014-04-29 02:37:58 +1000  BUG FIX: Was generating a redundant 'if true then X else _'
36ca55b  2014-04-29 02:37:18 +1000  Replaced DNode.DArgument with DVariable, which may or may not have a subexpression.
6b92c3a  2014-04-29 02:35:14 +1000  Started implementing monadic DFD generation logic.
6c7c79d  2014-04-29 02:46:02 +1000  TEMP: Disable outdated Graphviz code until the new DFD code is stable
2535b14  2014-04-28 10:59:33 +1000  BUG FIX: build failed when both mtl and monads-tf were installed, since they both contain Control.Monad.State
18ffe93  2014-04-27 01:22:06 +1000  BUG FIX: replaced explicit definition for show with inherited one (that does not trigger bug).
7f2e8de  2014-04-25 20:19:26 +1000  BUG FIX: The default implementation of show seems to cause stack overflows. Manually implementing it is a (inelegant) workaround. See: http://www.reddit.com/r/haskellquestions/comments/23xueu/ghc_bug_or_newbie_mistake/
4e4d0d4  2014-04-24 22:45:11 +1000  Rewrote pattern matching logic to correctly handle the case where none of the patterns impose constraints e.g. they are all variables
f07e733  2014-04-24 22:43:10 +1000  Added notes on debugging.

================================================================================
Tuesday 15 April 2014
Fixed bug affecting state monad. This bug can be solved more easily in the future by using scoped type annotations.
Function-level pattern matching has been implemented - need to refactor so that it can be used for arbitrary variables.
Code is now in good shape for the DFD node generation logic to be implemented. Once this is complete, the legacy Graphviz code will need to be updated to use the new interface.

Git commits:
210ca19  2014-04-15 22:56:45 +1000  Cleaned up code, removed legacy cruft
ff08611  2014-04-15 22:35:02 +1000  Implemented pattern matching logic.
007c353  2014-04-14 12:21:42 +1000  Fixed type inference bug. Was caused by not wrapping result in return.

================================================================================
Wednesday 09 April 2014
Started refactoring Graphviz code to separate graph traversal from code generation.
Key structures have been defined, algorithms just need to be ported across from existing code.
Currently having issues with state monad - need to prototype on smaller scale to identify the problem (something to do type inference).

Git commits:
d5f9124  2014-04-09 02:46:16 +1000  Added spike file to test monad code.
e0cee23  2014-04-09 02:04:11 +1000  WIP: NodeGen monad definition.
1ef7d7e  2014-04-06 22:34:41 +1000  Defined the DFD structure.
2d65e54  2014-04-06 20:04:49 +1000  Moved Graphviz generation code and type definitions into separate files.
aad45d1  2014-04-02 00:50:59 +1100  WIP
2e6bcb1  2014-03-25 23:00:42 +1100  Added script for submitting progress reports

================================================================================
Tuesday 25 March 2014
Implemented a rough prototype of Graphviz generation. It can generate the graph of f, but not fib, which requires pattern matching.
See H2V/test.hs for the source code, and H2V/test.png for the output. (The make debug target is responsible for rendering test.gv into test.png.)

Graph generation consists of a two step process:
-the AST is 'cleaned', to reduce the number of syntactic structures used. Any additional logic required is generated at this point.
-the cleaned AST (now referred to as a DFD) is transformed into Graphviz code via graph traversal
    +each function and variable has a node with a unique ID (implemented using a monotonically counting monad)
    +the traversal functions (which are defined recursively) keep track of the local namespace (a mapping between variable names and node IDs)
    +blue edges are used to identify functions that will undergo application (denoted by <-). Everything is curried right now, which isn't particularly readable - need to look at optimizing this in the future. (This may require the AST structure to be extended - the alternative is an external map which provides additional information. That said, we will need to store additional info later anyway in order to identify thunk boundaries)

-The pattern matching and function generation logic need to be rewritten; the current approach is a hack that is not sufficiently generalizable
-Graphviz generation is quite similar to Verilog generation. The main difference is that Verilog requires an explicit definition of the interfaces between nodes. It should be easy to implement Verilog generation once Graphviz generation is feature-complete.
-It looks like currying (partial application) will be possible; this arises quite naturally from mapping the function application operator (->) to a module which has an input (representing the argument), an input-output pair (representing a function of one argument), and another input-output pair (representing a partially applied function.) The inputs will vary in widths, depending on the degree of application. As this would result in many extraneous modules, combining as much application into a single module as possible is recommended.
    +This implies the rather useful insight that the generated visual graph is an exact representation of what the inter-module connections will be for a given program.

The Requirements Analysis has been submitted to Moodle.

Notes:
Documentation on parsing API:
    http://hackage.haskell.org/package/haskell-src-1.0.1.5/docs/Language-Haskell-Syntax.html

After populating the signals for a Qsys Component, you can go back to Files to
generate a file with the given signals.

Only reads can be pipelined, not writes. However, burst mode can be used for
both reads and writes. (Burst = accessing an entire row of data at once.)

Useful info on DE0-Nano SDRAM, and potential clock skew issues:
        ftp://ftp.altera.com/up/pub/Altera_Material/12.0/Tutorials/Verilog/DE0-Nano/Using_the_SDRAM.pdf

Git commits:
4ad668b  2014-03-25 22:08:45 +1100  Graph generation now works with subdeclarations. Pattern matching is broken (requires additional cleaning logic).
f8d67d2  2014-03-25 22:23:06 +1100  Graph generation now works, except for subdeclarations
a704d24  2014-03-24 19:56:22 +1100  Graphviz generation now working, except for argument resolution
c552d4c  2014-03-25 22:23:28 +1100  Improved Makefile to automate testing of Graphviz generation
f1dfc2a  2014-03-25 22:17:51 +1100  Node ID Counter monad now works.
d605911  2014-03-22 18:32:46 +1100  Moved build files into separate directory
7bf76db  2014-03-22 18:32:36 +1100  Refactored code into separate files
666cb8c  2014-03-22 17:47:09 +1100  Requirements Analysis: corrected typo.

================================================================================
Wednesday 19 March 2014
Read up on functors and monads. They seem to consist primarily of glue code
that does pattern matching and destructuring. However, if all stateful
operations (e.g. memory accesses) are encapsulated in them, then figuring out
how to schedule them via lazy evaluation may be non-trivial. A fake pure
function might be easier (for reads, anyway). They also imply a need for
first-class functions.

Familiarised myself with Qsys, and its interface for creating components.
Integrating the compiler with it should be easy.
In addition to the memory protocol, there is also a streaming protocol that
may be easy to support - need to see if it has any useful applications.

Notes:
Nios II Tutorial (useful as a checklist):
    http://www.altera.com/literature/tt/tt_nios2_hardware_tutorial.pdf

Summary of Qsys components:
    ftp://ftp.altera.com/up/pub/Altera_Material/12.0/Tutorials/making_qsys_components.pdf

Qsys Bus Protocol Specifications:
    http://www.altera.com/literature/manual/mnl_avalon_spec.pdf

Creating QSys Peripherals:
-create new component
-add interfaces, and enough signals to get rid of warnings
    +Clock Input
    +Reset Input
    +Avalon Memory Mapped Master (need waitrequest for multi-master)
    +Custom Instruction Slave
-add component to qsys file and hook it up to the buses
-signals are exported as conduits, unless verilog modules have been added to
handle them

This makes integrating into QSys really easy, and just requires us to
implement bus client logic.

The file generated by New Component is *_hw.tcl, and has a very simple format
that could easily be generated from a template.

Info on accelerator design:
    https://www.lri.fr/~de/ug_nios2_custom_instruction.pdf
    -can explicitly tell Quartus how many cycles we will take for fixed length
    functions

Git commits:
3d7b6a8  2014-03-19 00:03:52 +1100  Added scratch directory to gitignore. Useful for keeping spikes in.
d3ac736  2014-03-19 00:00:18 +1100  Completed Requirements Analysis
d57fd3e  2014-03-18 23:59:39 +1100  Added pin assignment file.
000e8b9  2014-03-16 22:52:25 +1100  Added notes on Haskell. Functor and Monad sections are now complete.

================================================================================
Tuesday 11 March 2014
Investigated use of GHC's parser. Decided against using it as there is a
standard library (haskell-src) better suited to this task.
Wrote a simple parsing spike to familiarise myself with haskell-src.

Added Risk Analysis and an early draft of the Requirements Analysis.
Basic structure and key requirements have been defined, some sections will require further research.

Notes:
The haskell standard libraries contains haskell-src, a library specifically
for parsing Haskell. This will be /much/ easier to use than GHC, since it will
not require reverse engineering. haskell-src-ext may also be useful.
    http://hackage.haskell.org/package/haskell-src
    http://hackage.haskell.org/package/haskell-src-1.0.1.5/docs/Language-Haskell-Parser.html

There's a Haskell to Javascript compiler here that could be interesting to
look at (in terms of how it handles parsing and AST manipulation).
    https://github.com/faylang/fay

Test input for parsing spike:
f x a b c = a2 * x + b * x + c where
    a2 = a * a

Test output for parsing spike:
Module: Main
        Function: f
                        Match:
                                Pattern: [HsPVar (HsIdent "x"),HsPVar (HsIdent "a"),HsPVar (HsIdent "b"),HsPVar (HsIdent "c")]
                                RHS: HsUnGuardedRhs (HsInfixApp (HsInfixApp (HsInfixApp (HsInfixApp (HsVar (UnQual (HsIdent "a2"))) (HsQVarOp (UnQual (HsSymbol "*"))) (HsVar (UnQual (HsIdent "x")))) (HsQVarOp (UnQual (HsSymbol "+"))) (HsVar (UnQual (HsIdent "b")))) (HsQVarOp (UnQual (HsSymbol "*"))) (HsVar (UnQual (HsIdent "x")))) (HsQVarOp (UnQual (HsSymbol "+"))) (HsVar (UnQual (HsIdent "c"))))
                                Declarations:
                                        Pattern Binding:
                                                Pattern: HsPVar (HsIdent "a2")
                                                RHS: HsUnGuardedRhs (HsInfixApp (HsVar (UnQual (HsIdent "a"))) (HsQVarOp (UnQual (HsSymbol "*"))) (HsVar (UnQual (HsIdent "a"))))
                                                Declarations:

Git commits:
9d40f9e  2014-03-11 19:53:56 +1100  Early draft of Requirements Analysis. Some sections are pending further research.
2a89fd7  2014-03-09 21:44:29 +1100  Parsing spike. Useful for examining code and familiarizing myself with the parser's types
11517af  2014-03-09 21:43:32 +1100  Added a file to hold use cases. Currently only contains Fibonnacci sequence.
a982a70  2014-03-05 19:52:49 +1100  Completed Risk Analysis
15ebc1a  2014-03-05 19:33:29 +1100  Moved files from project proposal into dedicated subdirectory

================================================================================
Wednesday 05 March 2014
Prototype and design proposal completed.

Git commits:
78d8a17  2014-03-04 23:17:51 +1100  Committed changes to report
4ea2686  2014-02-25 22:10:31 +1100  Completed prototype
540266d  2014-02-24 20:19:34 +1100  Added operator precedence
bc8b5f7  2014-02-24 19:08:08 +1100  Implemented printing of AST.
1e39577  2014-02-24 19:07:29 +1100  Replaced 2-tuple with a Function structure.
8c9c534  2014-02-24 18:16:49 +1100  Rewrote in Rust.
4adace7  2014-02-24 02:54:57 +1100  Implemented a large amount of parsing logic. At this point I'm giving up on a C++ implementation.
31f7a64  2014-02-19 21:09:19 +1100  Initial commit for H2V project
7feb560  2014-02-19 20:27:08 +1100  Updated design summary
9ed76ba  2014-02-16 22:07:30 +1100  Added discussion of Bison & Yacc
c3c8b00  2014-02-02 19:32:07 +1100  Initial commit - did first draft of preliminary design.

