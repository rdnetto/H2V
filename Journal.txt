================================================================================
Wednesday 13 August 2014
Attempting to use the fledgling closure code proved unsuccessful. Closures and higher order functions are sufficiently different that they are best handled separately.
I have decided to pass signals from functions, instead of evaluating them at compile-time. This is because compile-time evaluation is harder than originally predicted, and will make it almost impossible to handle user defined higher order functions. It is best handled as an optimization later, if necessary. This imposes the constraint that the result of a higher order function can only be called at one point in its function.

I have decided to require type-signatures for higher order functions, due to syntactic ambiguity. e.g. it cannot be determined whether
    f = foo x
returns a value or a function without knowing the type of foo. Since introspection of foo would be difficult, it is much easier to simply require foo has a type signature. Code for processing type signatures has been implemented.

Rendering of higher order functions in Verilog is currently a work in progress.

Git commits:
67bd0bc  2014-08-13 23:27:22 +1000  Revert "BUG FIX: give priority to functions" This breaks first-order functions.
a0721e9  2014-08-13 23:17:27 +1000  Changed header generation to use information present in the type signature, if available
8c058a7  2014-08-13 22:49:12 +1000  Added code to collect types from signatures and store them in the headers
88fb7d9  2014-08-13 22:48:14 +1000  Added support for collecting type signatures and matching them to functions. TODO: use these to define headers and identify higher order functions
abd2ec4  2014-08-13 21:26:03 +1000  Modified test case to explicitly use a functional alias
4e370a9  2014-08-13 21:25:22 +1000  Added Graphviz rendering support for lambdas
924245c  2014-08-13 21:12:29 +1000  BUG FIX: pattern bindings aren't necessarily CAFs
2f67192  2014-08-13 21:12:01 +1000  BUG FIX: resolveFunc wasn't checking the node namespace
f654bd0  2014-08-13 21:11:35 +1000  BUG FIX: give priority to functions This is only a short-term solution; we really should be keeping both nodes and functions in the same namespace
e03ad1f  2014-08-13 21:09:35 +1000  Refactored defineDecl so that nodes can exist in both namespaces.
a47e297  2014-08-12 22:09:42 +1000  Added support for lambda functions
72b7e59  2014-08-12 22:07:35 +1000  Created resolve(), and refactored resolution logic to have pure and impure variants. Catching exceptions can only be done in the IO monad, which is complex as resolution must be performed in the NodeGen monad. Splitting the code for throwing exceptions and performing resolution fixes this.
f76059e  2014-08-12 22:08:14 +1000  Added test case for higher order functions
794f622  2014-08-12 20:12:30 +1000  Temporarily removed closure test case

================================================================================
Wednesday 06 August 2014
Fixed issue with done signal using SignalTap (couldn't get ModelSim to work).
Attempting to get closure rewriting working before higher order functions, because they both involve the same kind of expression rewriting. Have rebased an experimental topic branch from May and making headway on it. (Compare test-master.png and test.png.)

Current state of closure rewriting:
f2c: both definition and call is correct
f2b: redef'd correctly, missing an arg (node_4)
f2a: some references are not being updated correctly. Also, the Graphviz rendering code is buggy
possible issue: what if a subgraph moved into a different scope contains an expression that needs to be rewritten?

Ideas for block diagram:
-each function is a box
-each box contains a graph representing parallelism. e.g. maps are expanded into a column
-function calls are shown as boxes
-all other expressions not shown, in order to simplify rendering (they're combinatorial anyway, so they can be neglected)

NOTE: parallel folds require monoids. i.e. an associative function and its identity. The built-in notation for this is a pain, so we should probably define a foldP that makes it easier to do this as a one-liner.
http://en.wikibooks.org/wiki/Haskell/Monoids

How to create a Modelsim simulation:
-right click on module -> Create Wave
-delete the output signals; only input signals should begin with 'Edit:'
-right click on the input signals and click Edit -> Create/Modify Waveform
    -define the input signals. If you switch to Edit mode, you can select and invert specific parts of the signal
-drag the output signals from the object window into wave window. They will begin with the prefix 'sim:'
use the command 'run -all'
-ISSUE: the output signals are shown as being undefined/'XXXXX'
-WORKAROUND: using SignalTap instead.

Git commits:
f012700  2014-08-06 23:35:53 +1000  Modified update-journal.sh to be non-interactive.
29301f8  2014-08-06 22:54:18 +1000  BUG FIX: we can't assume that the only nodes in the closure are variables
c701b37  2014-05-19 19:48:10 +1000  WIP: Closure support Code is mostly complete, but needs to be debugged. Leaving on a topic branch until I have enough time to do this properly.
d33bd20  2014-05-19 19:47:12 +1000  Function definition rewriting code
2198b5f  2014-05-19 20:02:27 +1000  Enabled closure rewriting
86686b6  2014-08-03 16:36:38 +1000  Added generated file to gitignore
2eb3f49  2014-08-03 16:34:50 +1000  Added testbench module for use with SignalTap, because unlike ModelSim its actually usable.
21caa5e  2014-08-03 16:30:42 +1000  BUG: done signal was late by one period, as it was being incorrectly clocked. Also renamed running to wasReady, since it's just ready delayed by a cycle.
4bfe819  2014-08-03 16:24:39 +1000  Removed less invocation from makefile

================================================================================
Meeting notes:
-to use Modelsim, go Tools -> Waves, add signals, then use the command 'run 1000ns'
-need to generate a decent block diagram, which shows parallel constructs, sequential loops, etc.
-should research pipelining DFDs
-loop unrolling is pointless for seq logic - it's only applicable to map-reduce
-add examples of higher order functions to journal/email to David

-TODO: finish ready/done signals, higher order funcs -> lists -> DMA

================================================================================
Wednesday 30 July 2014
Simulated and debugged Fibonacci generator test case (see Functional-Sim.vwf). Now working, apart from some minor issues.
There is currently a bug where the value of the done signal lags the expected value by 1 clock cycle.
There also seems to be some slight weirdness with the function not resetting correctly.

Using ModelSim via Quartus' Simulation Waveform Editor, since it is *much* easier to use.


Git commits:
ad279f2  2014-07-30 23:36:26 +1000  Updated journal uploading script
09688ed  2014-07-30 23:32:35 +1000  Added Quartus project used for simulations
445442f  2014-07-29 16:25:48 +1000  Partially implement ready/done signalling. Need to do this for the cases of a recursive function later.
f276e78  2014-07-29 15:17:18 +1000  BUG: We were performing an extra iteration since done lagged by one cycle (Also, we weren't ceasing iteration at all).
d7031be  2014-07-29 15:10:47 +1000  BUG: ready/done signals were disconnected
fba63f7  2014-07-29 15:10:27 +1000  BUG: If we're not recursing, we need to set done to stop iterating
fc640da  2014-07-29 11:45:14 +1000  Makefile: disabled profiling
cf86b06  2014-07-23 22:13:07 +1000  Modelsim assumes implicit nets are 1 bit wide, so we need to define them explicitly.
7a42a20  2014-07-23 22:02:48 +1000  Refactored VNodeDef into a record, since we need to store definitions and assignments seperately.
aeb767b  2014-07-23 20:59:03 +1000  Refactored VNode extraction logic into a separate function
1a71de9  2014-07-23 20:45:45 +1000  Modelsim requires modules be defined before they are used This corrects the generation of recursive functions. Still need to fix the generation order of regular functions
94f020a  2014-07-23 20:32:28 +1000  Modelsim treats unnamed modules as an error, so give them names.
d67100b  2014-07-23 20:39:50 +1000  Removed obsolete comment
2e35e6d  2014-07-23 18:34:10 +1000  BUG FIX: mixed up indices
b43232a  2014-07-21 22:15:52 +1000  Added an explicit default branch with don't cares to prevent latches from being inferred.
3a988dd  2014-07-21 21:58:33 +1000  Modified code to use an implicit sensitivity list (less error prone).
e404804  2014-07-21 21:34:18 +1000  BUG FIX: wasn't actually checking the value of useNodeId
7948f4e  2014-07-21 21:33:48 +1000  BUG FIX: different recursive cases may share DFD subgraphs, so we need to return VNodeDefs
28aa0fd  2014-07-21 20:10:42 +1000  Added some newlines for readability
328327c  2014-07-21 19:57:17 +1000  BUG FIX: mixed up the input and output args
3e9e6cc  2014-07-21 19:53:17 +1000  Corrected generated combinatorial modules so that they were actually combinatorial (i.e. not clocked). Note that the reg keyword must be used for any output variable set via an always block (but not via assign). Also refactored the muxing logic to be cleaner.
3306835  2014-07-21 19:05:57 +1000  Corrected typo
982f22b  2014-07-21 19:00:43 +1000  BUG FIX: DFD and Node IDs exist in separate namespaces, so we can't just use the DFD ID to describe the result node
fba9dae  2014-07-21 18:52:04 +1000  BUG FIX: mixed up semicolons and commas
a388b5a  2014-07-15 23:01:21 +1000  Corrected formatting errors in generated Verilog
d561871  2014-07-15 23:00:55 +1000  Changed Makefile's test target, since we're now focusing on Verilog
c0c75cd  2014-07-15 21:51:57 +1000  BUG FIX: removed code performing testing for indirect recursion, since it was buggy and only used to check for error conditions.
100c2da  2014-07-15 21:40:20 +1000  BUG FIX: mixed up which was supposed to be true
7dd7f8d  2014-07-15 21:38:56 +1000  WIP: Added code for handling recursive cases (assumes combinatorial case selection)
c585aa8  2014-07-15 21:37:12 +1000  Refactored Verilog rendering code to use a typedef for the recursive case record
897147e  2014-07-15 21:35:29 +1000  Added definitions for isLeft, isRight, because GHC can't find them
56fcb2b  2014-06-02 00:05:08 +1000  WIP
c707988  2014-05-31 23:13:47 +1000  Implemented logic for detecting recursive functions.

================================================================================
Note: projector is 1280x1024
There's an absolutely fantastic reference here that I should read sometime:
    http://www.jucs.org/jucs_11_7/hardware_design_and_functional/jucs_11_7_1135_1158_sheeran.pdf


TODO: create mock up of how the power method would look, and what the structure of its Verilog would look like
-also consider finding something that doesn't need square roots
-Taylor series approx of square root could work quite well, as long as we handle the exponents in a sane way
    Probably should just implement the square root function in Verilog, because it's not going to map nicely to Haskell

================================================================================
Wednesday 28 May 2014
Have mostly completed draft of design report, except for some minor additions.

Summary of points from email (to be discussed in meeting):
-benchmarks / test functions with Verilog, DFDs, discussion, etc. - to be added later today
-expected difficulties - main one would be insufficient time for all of the optimizations. Have already marked QSys integration to be dropped if this is the case - should I discuss this more clearly?
-code excerpts for core features (C, Haskell, Verilog, block diagrams) is a good idea, but there is probably not enough time to get it done in time for the report
-RE: listings 1 and 2, I have added a block diagram and reworded the discussion
-looking at other HDL generating tools is a good idea, but definitely something to think about later.

Git commits:
a2fced1  2014-05-28 03:57:10 +1000  Minor bug fix
e674e8b  2014-05-28 03:32:58 +1000  Added block diagram to demonstrate parallel mapping.
138c996  2014-05-28 02:45:59 +1000  Added some example code to demonstrate parallel list processing.
e918930  2014-05-28 01:44:10 +1000  Added source code to design spec, defined syntax highlighting rules
270e7f4  2014-05-28 01:41:48 +1000  Added diagrams
cd4d8eb  2014-05-27 03:14:03 +1000  Completed draft of design spec. Need to add diagrams, fix citations.
3a297a1  2014-05-26 02:27:54 +1000  WIP: Design Spec - up to 1.4. Using Latex.

================================================================================
Notes on C2H:

http://www.altera.com/literature/ug/ug_nios2_c2h_compiler.pdf
-C to hardware mapping: [pg 17]
    +"The C2H Compiler translates each element of C syntax to an equivalent
      hardware structure using straightforward mapping rules. The mapping
      rules provide a one-to-one association between elements of C syntax and
      their equivalent hardware structures." - pg. 41, implies the limitations of C syntax are significant
    +loops become state machines (subject to pipelining)
    +pointer dereferences, array accesses are direct reads (via avalon); no caching
    +each function is only mapped to a single hardware instance (per top-level function) [pg 52]
    +no inline functions; how you organize the code affects the generated logic [pg 53]
    +structs/arrays are stored in memory, and only one field/element can be accessed per cycle. Local arrays/structs do not consume memory, but still use Avalon bus and are therefore still limited to one element per cycle [pg 54]
    +global/static variables are passed in as pointers; access is expensive
    +generates one Avalon master for *each* memory access operation - can result in *significant* bottlenecks memory-side
    +memory aliases introduce false dependencies; write operations via pointer/array must be completeted before subsequent reads from *any* memory location. This can be corrected with __restrict__, but is easy to forget or apply incorrectly. [pg 76]
    +functions are represented as sequential state machines; unrelated computations placed in the same state mean that one computation can block another. Cf H2V, where functions are represented as the propagation of data. [pg 81]
    +C2H has loop pipelining, but because it uses single port Avalon-MM it cannot implement loop unrolling.

-C2H does not support recursion
-C2H does not replicate side-effects correctly. e.g. short-circuit operators [pg 128]
-many of the recommended practices for C2H are syntactic requirements of functional languages (e.g. replacing global variables with arguments)
-do a speed comparison between H2V and C2H for trivial functions - it is likely that C2H is significantly slower
-more control over integer widths - C2H only provides ANSI C types (8, 16, 32, 64)
-each assignment is registered; implies significant increase to CPI [pg 43-44]
    +this is done to increase pipelining, but is excessive
    +the placement of registers is fixed with respect the syntax [e.g. pg 48-49]. This is inferior to dividing nodes following a timing analysis

TODO: need to add code to flush data cache to wrapper function, to avoid cache coherency issues
TODO: mention endianness (Nios uses little endian)

paradigm example: for loop vs map

================================================================================
Wednesday 21 May 2014
Have postponed closure support, as it is non-essential and taking longer than expected to debug.
Graphviz generation of nested (non-closure) functions now works - refer to H2V/test.png.
Preliminary Verilog generation is working (see H2V/test.v). Currently only combinatorial functions are supported, and we guess the type a lot. However, it does synthesize correctly in Quartus.
Need to extend module definitions to include start/done signals for synchronous functions.
Generation of Verilog for recursive functions fails due to a linking bug - need to fix this later.
Wrote a rough plan for the design spec, will be expanded upon over the next week (due Wed 30).

Git commits:
master branch:
95cae44  2014-05-21 00:41:16 +1000  Wrote rough plan of design specification.
3131219  2014-05-20 00:19:55 +1000  BUG FIX: changed 'if' from BinaryOP to Ternary. Added DBool type.
694474c  2014-05-20 00:19:04 +1000  Preliminary Verilog generation
664aec7  2014-05-19 23:03:49 +1000  Rewrote Graphviz rendering code so that all nodes are defined before edges, to ensure that they are placed in the correct functions.
70dc45e  2014-05-19 22:01:23 +1000  BUG FIX: dmap, etc. were not recursive
fdbd7a5  2014-05-19 20:41:09 +1000  BUG FIX: Built-in functions should not be rendered
a299409  2014-05-19 19:53:00 +1000  Fixed collectedDfds to handle recursive functions.
ba5b112  2014-05-19 19:45:02 +1000  Helper functions
9ce1164  2014-05-19 19:42:46 +1000  Added code for identifying foreign nodes
993c202  2014-05-19 19:41:59 +1000  Added code for collecting nested functions. (Part 1)
9b3047a  2014-05-17 18:03:30 +1000  Refactored logic for mapping/folding over the DFD into separate functions.
6f13afd  2014-05-16 22:03:06 +1000  Created a CLI, and a template file for Verilog generation.
3d9b668  2014-05-16 22:00:16 +1000  Added brackets to quadratic test case as a workaround for a haskell-src bug

closures topic branch:
cb73f3f  2014-05-19 19:48:10 +1000  WIP: Closure support Code is mostly complete, but needs to be debugged. Leaving on a topic branch until I have enough time to do this properly.
30563d2  2014-05-19 19:47:12 +1000  Function definition rewriting code
427a87e  2014-05-19 20:02:27 +1000  Enabled closure rewriting
a299409  2014-05-19 19:53:00 +1000  Fixed collectedDfds to handle recursive functions.

================================================================================
Notes from meeting of 14-05-2014:
For Verilog generation of recursive functions, let there be a synchronous
module which handles recursive logic, and a combinatorial module that
implements actual logic. This will greatly simplify loop unrolling.

GOAL: generate synchronous Verilog in time for presentation.e.g. Fibonnacci
sequence. Also implement eigenvalue power method.
Include block diagrams of expected Verilog output for recursive functions in
design report.

Presentation should focus on what it will be able to do, as opposed to what it
can do.

================================================================================
Wednesday 14 May 2014
Implemented DFD generation for nested and recursive functions.
Preliminary Graphviz generation is now implemented - see H2V/test.png for an example of this.

Note that f3 does not render correctly because f2c relies on a closure. (Also,
nested functions aren't being rendered anyway.) Currently working on rewriting
closures as function arguments, but this logic is surprisingly complex.

The logic for collecting nested functions and performing closure rewriting has
been combined, since both require a traversal of the DFD to find functions.

Git commits:
ac6ad64  2014-05-13 23:59:21 +1000  WIP: closure rewriting
c287678  2014-05-13 23:53:45 +1000  Added nodeChildren, since it's a fairly common operation.
c5809d1  2014-05-13 23:53:14 +1000  Added some general purpose monadic methods to Common.
05c7bfe  2014-05-13 19:55:33 +1000  Added function list to state monad
68c1244  2014-05-12 22:45:41 +1000  Renamed resolveIdDFD to resolveHeader, since it facilitates better error messages
d54c008  2014-05-12 22:34:56 +1000  Refactored DFD and DNode to use record syntax, as it simplifies some expressions.
c2d338e  2014-05-12 21:43:39 +1000  Added some headings to DfdDef
f814d98  2014-05-12 21:32:00 +1000  Refactored NodeGenData into a record, since this enables neater syntax and allows fields to be added/removed more easily.
37de45d  2014-05-12 20:08:25 +1000  BUG FIX: where the data path forked and merged, nodes were being defined multiple times
c0ef5da  2014-05-12 20:07:36 +1000  Added list of arguments (and their types) to function definition.
d71a3e9  2014-05-11 19:34:34 +1000  Added an explicit type for use when type has not been specified.
12a86cc  2014-05-11 19:27:07 +1000  WIP: Graphviz generation. Nested functions are not rendered. Need to add no. of args to DFD.
78ee0cc  2014-05-11 17:50:32 +1000  Changed function linking to use UIDs instead of names. This avoids issues related to shadowing.
b6914cb  2014-05-11 17:25:56 +1000  Added support for nested, recursive functions.
954bd20  2014-05-11 15:58:19 +1000  Improved DFD resolution error messages to specify which functions are only headers.
47e829e  2014-05-11 15:48:14 +1000  Merged createDFD into defineDecl(HsFunBind). defineDecl now returns both nodes and DFDs, which is handled by popNS/pushNS. This enables nested functions.
0414b5a  2014-05-11 14:48:35 +1000  Added test case for nested functions
44177a3  2014-05-11 14:48:00 +1000  Moved language extension flags into Makefile
056bbc1  2014-05-11 14:21:16 +1000  Added logic for defining function headers before functions. This is used by recursive functions.

================================================================================
Wednesday 07 May 2014
DFD generation code is now almost completely functional. Implemented data
dependency resolution code, so that variables and functions can be defined in arbitary
order.

Nested functions are not yet implemented (requires adjustments to dependency
resolution to handle closure correctly). Recursive functions are also
currently not functional, since they refer to themselves before they are
defined. Both of these require only minor fixes.

Graphviz generation (and possibly Verilog) should be attainable by next week.
Report is due Wed 28 May, so should probably start that soon. (Presentation is
due the week after.)

Git commits:
21c170b  2014-05-06 19:23:00 +1000  BUG FIX: Since the namespace is stored as a stack, we need to pop in reverse order.
cf872a0  2014-05-06 19:22:14 +1000  Reduced verbosity of node resolution error messages, since all we care about are the names.
fd16aea  2014-05-06 19:21:38 +1000  Added tShow to Common. Useful when debugging.
b59bb06  2014-05-06 19:01:42 +1000  Refactored namespace storage to use 1D lists, since we never push more than one element at at time.
1876d7c  2014-05-06 19:00:48 +1000  BUG FIX: We now push declarations to the namespace immediately on creation. This is necessary so that
b700339  2014-05-06 20:16:55 +1000  Added test case for dependency resolution
3de1198  2014-05-03 10:48:31 +1000  Added dependency resolution code so that declarations are evaluated in the correct order.
534be5a  2014-05-03 10:12:55 +1000  Implemented a custom exception for node resolution failure. This was originally going to be used for try-catch structures, but is now used only to format error messages.
e251e5f  2014-05-03 03:39:37 +1000  WIP: Part 1 of arbitrary term definition order
1fb90d2  2014-05-03 01:38:15 +1000  Refactored prelude definitions
70bc6e7  2014-05-03 01:37:47 +1000  BUG FIX: was using an unsanitised version of the arguments from the first match, which could include patterns

================================================================================
Wednesday 30 April 2014
Encountered a temporary set-back related to a GHC bug where undefined
typeclass members could result in stack overflows. Found a workaround, but
spent most of the break doing doing so.

DFD generation code is slowly underway - implementing support for expressions one at a
time as required by test case (Fibonacci sequence).

The minimal implementation may be larger than expected due to
interdependencies. e.g. pattern matching requires if statements, which require
the ability to import functions from Prelude. However, this does not change
the overall implementation time because these features would need to be
implemented sooner or later anyway.


Git commits:
83108f4  2014-04-30 00:56:52 +1000  WIP: adding support for IF statements
93b515e  2014-04-30 00:58:22 +1000  TEMP: Changed test.hs so that functions are in strict dependency order. Revert once we have better dependency resolution
4c6c526  2014-04-29 02:42:53 +1000  Added support for let statements, function application.
336a832  2014-04-29 02:41:54 +1000  Preliminary: added some basic definitions of built-in operators
2497610  2014-04-29 02:40:53 +1000  Added utility methods for converting qualified names to strings, removed stale code.
770ce6f  2014-04-29 02:38:45 +1000  BUG FIX: State modification code was commented out
4139525  2014-04-29 02:37:58 +1000  BUG FIX: Was generating a redundant 'if true then X else _'
36ca55b  2014-04-29 02:37:18 +1000  Replaced DNode.DArgument with DVariable, which may or may not have a subexpression.
6b92c3a  2014-04-29 02:35:14 +1000  Started implementing monadic DFD generation logic.
6c7c79d  2014-04-29 02:46:02 +1000  TEMP: Disable outdated Graphviz code until the new DFD code is stable
2535b14  2014-04-28 10:59:33 +1000  BUG FIX: build failed when both mtl and monads-tf were installed, since they both contain Control.Monad.State
18ffe93  2014-04-27 01:22:06 +1000  BUG FIX: replaced explicit definition for show with inherited one (that does not trigger bug).
7f2e8de  2014-04-25 20:19:26 +1000  BUG FIX: The default implementation of show seems to cause stack overflows. Manually implementing it is a (inelegant) workaround. See: http://www.reddit.com/r/haskellquestions/comments/23xueu/ghc_bug_or_newbie_mistake/
4e4d0d4  2014-04-24 22:45:11 +1000  Rewrote pattern matching logic to correctly handle the case where none of the patterns impose constraints e.g. they are all variables
f07e733  2014-04-24 22:43:10 +1000  Added notes on debugging.

================================================================================
Tuesday 15 April 2014
Fixed bug affecting state monad. This bug can be solved more easily in the future by using scoped type annotations.
Function-level pattern matching has been implemented - need to refactor so that it can be used for arbitrary variables.
Code is now in good shape for the DFD node generation logic to be implemented. Once this is complete, the legacy Graphviz code will need to be updated to use the new interface.

Git commits:
210ca19  2014-04-15 22:56:45 +1000  Cleaned up code, removed legacy cruft
ff08611  2014-04-15 22:35:02 +1000  Implemented pattern matching logic.
007c353  2014-04-14 12:21:42 +1000  Fixed type inference bug. Was caused by not wrapping result in return.

================================================================================
Wednesday 09 April 2014
Started refactoring Graphviz code to separate graph traversal from code generation.
Key structures have been defined, algorithms just need to be ported across from existing code.
Currently having issues with state monad - need to prototype on smaller scale to identify the problem (something to do type inference).

Git commits:
d5f9124  2014-04-09 02:46:16 +1000  Added spike file to test monad code.
e0cee23  2014-04-09 02:04:11 +1000  WIP: NodeGen monad definition.
1ef7d7e  2014-04-06 22:34:41 +1000  Defined the DFD structure.
2d65e54  2014-04-06 20:04:49 +1000  Moved Graphviz generation code and type definitions into separate files.
aad45d1  2014-04-02 00:50:59 +1100  WIP
2e6bcb1  2014-03-25 23:00:42 +1100  Added script for submitting progress reports

================================================================================
Tuesday 25 March 2014
Implemented a rough prototype of Graphviz generation. It can generate the graph of f, but not fib, which requires pattern matching.
See H2V/test.hs for the source code, and H2V/test.png for the output. (The make debug target is responsible for rendering test.gv into test.png.)

Graph generation consists of a two step process:
-the AST is 'cleaned', to reduce the number of syntactic structures used. Any additional logic required is generated at this point.
-the cleaned AST (now referred to as a DFD) is transformed into Graphviz code via graph traversal
    +each function and variable has a node with a unique ID (implemented using a monotonically counting monad)
    +the traversal functions (which are defined recursively) keep track of the local namespace (a mapping between variable names and node IDs)
    +blue edges are used to identify functions that will undergo application (denoted by <-). Everything is curried right now, which isn't particularly readable - need to look at optimizing this in the future. (This may require the AST structure to be extended - the alternative is an external map which provides additional information. That said, we will need to store additional info later anyway in order to identify thunk boundaries)

-The pattern matching and function generation logic need to be rewritten; the current approach is a hack that is not sufficiently generalizable
-Graphviz generation is quite similar to Verilog generation. The main difference is that Verilog requires an explicit definition of the interfaces between nodes. It should be easy to implement Verilog generation once Graphviz generation is feature-complete.
-It looks like currying (partial application) will be possible; this arises quite naturally from mapping the function application operator (->) to a module which has an input (representing the argument), an input-output pair (representing a function of one argument), and another input-output pair (representing a partially applied function.) The inputs will vary in widths, depending on the degree of application. As this would result in many extraneous modules, combining as much application into a single module as possible is recommended.
    +This implies the rather useful insight that the generated visual graph is an exact representation of what the inter-module connections will be for a given program.

The Requirements Analysis has been submitted to Moodle.

Notes:
Documentation on parsing API:
    http://hackage.haskell.org/package/haskell-src-1.0.1.5/docs/Language-Haskell-Syntax.html

After populating the signals for a Qsys Component, you can go back to Files to
generate a file with the given signals.

Only reads can be pipelined, not writes. However, burst mode can be used for
both reads and writes. (Burst = accessing an entire row of data at once.)

Useful info on DE0-Nano SDRAM, and potential clock skew issues:
        ftp://ftp.altera.com/up/pub/Altera_Material/12.0/Tutorials/Verilog/DE0-Nano/Using_the_SDRAM.pdf

Git commits:
4ad668b  2014-03-25 22:08:45 +1100  Graph generation now works with subdeclarations. Pattern matching is broken (requires additional cleaning logic).
f8d67d2  2014-03-25 22:23:06 +1100  Graph generation now works, except for subdeclarations
a704d24  2014-03-24 19:56:22 +1100  Graphviz generation now working, except for argument resolution
c552d4c  2014-03-25 22:23:28 +1100  Improved Makefile to automate testing of Graphviz generation
f1dfc2a  2014-03-25 22:17:51 +1100  Node ID Counter monad now works.
d605911  2014-03-22 18:32:46 +1100  Moved build files into separate directory
7bf76db  2014-03-22 18:32:36 +1100  Refactored code into separate files
666cb8c  2014-03-22 17:47:09 +1100  Requirements Analysis: corrected typo.

================================================================================
Wednesday 19 March 2014
Read up on functors and monads. They seem to consist primarily of glue code
that does pattern matching and destructuring. However, if all stateful
operations (e.g. memory accesses) are encapsulated in them, then figuring out
how to schedule them via lazy evaluation may be non-trivial. A fake pure
function might be easier (for reads, anyway). They also imply a need for
first-class functions.

Familiarised myself with Qsys, and its interface for creating components.
Integrating the compiler with it should be easy.
In addition to the memory protocol, there is also a streaming protocol that
may be easy to support - need to see if it has any useful applications.

Notes:
Nios II Tutorial (useful as a checklist):
    http://www.altera.com/literature/tt/tt_nios2_hardware_tutorial.pdf

Summary of Qsys components:
    ftp://ftp.altera.com/up/pub/Altera_Material/12.0/Tutorials/making_qsys_components.pdf

Qsys Bus Protocol Specifications:
    http://www.altera.com/literature/manual/mnl_avalon_spec.pdf

Creating QSys Peripherals:
-create new component
-add interfaces, and enough signals to get rid of warnings
    +Clock Input
    +Reset Input
    +Avalon Memory Mapped Master (need waitrequest for multi-master)
    +Custom Instruction Slave
-add component to qsys file and hook it up to the buses
-signals are exported as conduits, unless verilog modules have been added to
handle them

This makes integrating into QSys really easy, and just requires us to
implement bus client logic.

The file generated by New Component is *_hw.tcl, and has a very simple format
that could easily be generated from a template.

Info on accelerator design:
    https://www.lri.fr/~de/ug_nios2_custom_instruction.pdf
    -can explicitly tell Quartus how many cycles we will take for fixed length
    functions

Git commits:
3d7b6a8  2014-03-19 00:03:52 +1100  Added scratch directory to gitignore. Useful for keeping spikes in.
d3ac736  2014-03-19 00:00:18 +1100  Completed Requirements Analysis
d57fd3e  2014-03-18 23:59:39 +1100  Added pin assignment file.
000e8b9  2014-03-16 22:52:25 +1100  Added notes on Haskell. Functor and Monad sections are now complete.

================================================================================
Tuesday 11 March 2014
Investigated use of GHC's parser. Decided against using it as there is a
standard library (haskell-src) better suited to this task.
Wrote a simple parsing spike to familiarise myself with haskell-src.

Added Risk Analysis and an early draft of the Requirements Analysis.
Basic structure and key requirements have been defined, some sections will require further research.

Notes:
The haskell standard libraries contains haskell-src, a library specifically
for parsing Haskell. This will be /much/ easier to use than GHC, since it will
not require reverse engineering. haskell-src-ext may also be useful.
    http://hackage.haskell.org/package/haskell-src
    http://hackage.haskell.org/package/haskell-src-1.0.1.5/docs/Language-Haskell-Parser.html

There's a Haskell to Javascript compiler here that could be interesting to
look at (in terms of how it handles parsing and AST manipulation).
    https://github.com/faylang/fay

Test input for parsing spike:
f x a b c = a2 * x + b * x + c where
    a2 = a * a

Test output for parsing spike:
Module: Main
        Function: f
                        Match:
                                Pattern: [HsPVar (HsIdent "x"),HsPVar (HsIdent "a"),HsPVar (HsIdent "b"),HsPVar (HsIdent "c")]
                                RHS: HsUnGuardedRhs (HsInfixApp (HsInfixApp (HsInfixApp (HsInfixApp (HsVar (UnQual (HsIdent "a2"))) (HsQVarOp (UnQual (HsSymbol "*"))) (HsVar (UnQual (HsIdent "x")))) (HsQVarOp (UnQual (HsSymbol "+"))) (HsVar (UnQual (HsIdent "b")))) (HsQVarOp (UnQual (HsSymbol "*"))) (HsVar (UnQual (HsIdent "x")))) (HsQVarOp (UnQual (HsSymbol "+"))) (HsVar (UnQual (HsIdent "c"))))
                                Declarations:
                                        Pattern Binding:
                                                Pattern: HsPVar (HsIdent "a2")
                                                RHS: HsUnGuardedRhs (HsInfixApp (HsVar (UnQual (HsIdent "a"))) (HsQVarOp (UnQual (HsSymbol "*"))) (HsVar (UnQual (HsIdent "a"))))
                                                Declarations:

Git commits:
9d40f9e  2014-03-11 19:53:56 +1100  Early draft of Requirements Analysis. Some sections are pending further research.
2a89fd7  2014-03-09 21:44:29 +1100  Parsing spike. Useful for examining code and familiarizing myself with the parser's types
11517af  2014-03-09 21:43:32 +1100  Added a file to hold use cases. Currently only contains Fibonnacci sequence.
a982a70  2014-03-05 19:52:49 +1100  Completed Risk Analysis
15ebc1a  2014-03-05 19:33:29 +1100  Moved files from project proposal into dedicated subdirectory

================================================================================
Wednesday 05 March 2014
Prototype and design proposal completed.

Git commits:
78d8a17  2014-03-04 23:17:51 +1100  Committed changes to report
4ea2686  2014-02-25 22:10:31 +1100  Completed prototype
540266d  2014-02-24 20:19:34 +1100  Added operator precedence
bc8b5f7  2014-02-24 19:08:08 +1100  Implemented printing of AST.
1e39577  2014-02-24 19:07:29 +1100  Replaced 2-tuple with a Function structure.
8c9c534  2014-02-24 18:16:49 +1100  Rewrote in Rust.
4adace7  2014-02-24 02:54:57 +1100  Implemented a large amount of parsing logic. At this point I'm giving up on a C++ implementation.
31f7a64  2014-02-19 21:09:19 +1100  Initial commit for H2V project
7feb560  2014-02-19 20:27:08 +1100  Updated design summary
9ed76ba  2014-02-16 22:07:30 +1100  Added discussion of Bison & Yacc
c3c8b00  2014-02-02 19:32:07 +1100  Initial commit - did first draft of preliminary design.

